{
    "list": [
        {
            "toc": [],
            "state": "publish",
            "readingQuantity": 0,
            "createAt": "2019-04-15T15:46:19.442Z",
            "updateAt": "2019-04-14T14:22:39.347Z",
            "_id": "5cb4a74b15b14b29fb28e02c",
            "id": null,
            "content": "![2018 前端性能优化清单思维导图](https://user-gold-cdn.xitu.io/2018/2/28/161db9df64a2f3c1?w=1490&h=3002&f=png&s=709772)\n\n我们都知道性能很重要，但是，我们是否真的一直都知道我们性能优化的瓶颈在哪？是代价昂贵的 JavaScript？是 web 字体很慢？还是比较大的图片？或者是渲染速度过于迟缓？tree-shaking（无用代码移除）、scope hoisting（作用域提升）、code-splitting（按需加载）、 intersection observer 以及 clients hints、CSS containment、HTTP/2 和 service workers 这些技术都是有利于性能优化的。并且，最重要的是，**我们要从哪里开始提升我们的性能呢**？并且要怎么建立长久有效的性能机制。\n\n\n译者注：\n- `tree-shaking`：`tree-shaking` 是 Webpack 2 引入的新功能，`tree-shaking` 是无用代码移除（DCE, dead code elimination）的一个方法，但和传统的方法不太一样。`tree-shaking` 找到需要的代码，灌入最终的结果；传统 DCE 找到执行不到的代码，从 AST 里清除。—— [如何评价 Webpack 2 新引入的 Tree-shaking 代码优化技术？](https://www.zhihu.com/question/41922432)\n- `scope hoisting`：`scope hoisting` 是 Webpack 3 的新功能，又译作“作用域提升”。Webpack 将所有模块都用函数包裹起来，然后自己实现了一套模块加载、执行与缓存的功能，使用这样的结构是为了更容易实现 Code Splitting（包括按需加载）、模块热替换等功能。—— [Webpack 3 的新功能：Scope Hoisting](https://zhuanlan.zhihu.com/p/27980441)\n- `code-splitting`：对于大型的 web 应用而言，把所有的代码放到一个文件的做法效率很差，特别是在加载了一些只有在特定环境下才会使用到的阻塞的代码的时候。Webpack有个功能会把你的代码分离成Chunk，后者可以按需加载。这个功能就是`code-splitting`。—— [在Webpack中使用Code Splitting实现按需加载](http://www.alloyteam.com/2016/02/code-split-by-routes/)\n- `intersection observer`：可以自动\"观察\"元素是否可见，由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做\"交叉观察器\"。—— [IntersectionObserver API 使用教程](http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html)\n- `clients hints`：自动响应式图片 —— [Automatic responsive images with Client Hints](https://cloudinary.com/blog/automatic_responsive_images_with_client_hints)\n- `CSS containment`：新的 CSS 属性 Containment 允许开发者限制浏览器样式、布局和 paint 工作的范围。—— [CSS Containment in Chrome 52](https://developers.google.com/web/updates/2016/06/css-containment)\n- `service workers`：实现离线页面 ——[Service worker concepts and usage](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)\n\n\n在以前，性能优化经常是在项目完成才去考虑的，经常被推迟到项目的末期，这样优化的范围就会缩小，优化的内容通常是优化静态文件和调整一些服务器配置文件。但是现在，性能优化发生了很大的改变，这些是远远不够的。\n\n性能不仅仅是一个技术问题：重要的是，当将它放入工作流中的时候，做出的设计决策必须受性能的提示。**性能必须被测量、监测和完善**，而网络日益增长的复杂性也使得跟踪性能的度量原来越难，因为度量会根据设备、浏览器、协议、网络类型和延迟而显着变化（CDN，ISP，缓存，代理，防火墙，负载均衡器和服务器都在性能上发挥作用）。\n\n所以，我们就必须时刻记住性能优化 —— 从项目开始的时候直到网站最后发布。所以我们就创建了一个性能优化列表。（希望是公正的和客观的）2018 前端性能检查表 —— 可以帮助你解决你网站的优化问题，例如，响应时间如何更快，流畅的用户交互和不会流失用户的带宽。\n\n（你也可以仅下载 2018 前端性能优化清单 的 [PDF 版本]((https://www.dropbox.com/s/8h9lo8ee65oo9y1/front-end-performance-checklist-2018.pdf?dl=0))（0.129 MB）或者下载 [Apple Pages 版本](https://www.dropbox.com/s/yjedzbyj32gzd9g/performance-checklist-1.1.pages?dl=0)（0.236 MB））\n\n### 准备就绪：计划和度量\n微小的优化对于保持性能也是十分重要的，但是时刻记着我们必须要有一个明确的目标，可度量的目标将影响整个过程中的任何决策。这里有几种不同的模式，并且下面的方法都是从自身角度出发，所以你要尽早确认你自己优化的优先级。\n\n1. 树立性能优化意识\n\n在很多团队中，前端开发者确切的知道常见的潜在问题是什么，应该用什么样的加载模块来修复。然而，只要开发或者设计那边有一方跟市场的意见不合，性能就不会长时间持续下去。所以，研究用户常见的抱怨的地方，看看提高性能如何帮助解决这些常见问题。\n\n无论是在移动设备上还是在桌面上都需要运行性能实验并测量结果。 它会建立一个用真实数据为你们公司量身定制的案例研究。此外，要善于使用 [WPO Stats](https://wpostats.com/) 上发布的案例研究和实验中的数据，可以帮助提高你对性能和业务之前潜在关系的认识，以及性能对用户体验和业务度量的影响。仅仅说明绩效是不够的 - 你还需要建立一些可衡量和可追踪的目标来观察性能。\n \n2. 目标：至少要比你最快的竞争对手还快 20%\n\n根据 [心理学研究](https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/#the-need-for-performance-optimization-the-20-rule)，如果你想要用户感觉你的网站比你竞争者的网站快，那么你至少需要比它们快 20%。研究你的主要竞争者，收集他们在手机和桌面上的性能，并且设置一个你能超过他们的临界值。要获取准确的结果和目标，首先要研究你的分析结果，看看你的用户都在做什么。你可以模拟第百分之九十的用户经验进行测试，收集数据，然后建立一个 [表格](http://v3.danielmall.com/articles/how-to-make-a-performance-budget/)，然后再减去 20% 就是你的目标（即 [性能预算](http://bradfrost.com/blog/post/performance-budget-builder/)）。现在你在测试之前就有了一些可度量的数据。\n\n如果你比较在意预算并尝试去用最小的脚本来获得最快的交互时间，那么你就开始了你的“前端优化之旅”。Lara Hogan 关于如何使用性能预算来处理设计的 [指南](http://designingforperformance.com/weighing-aesthetics-and-performance/#approach-new-designs-with-a-performance-budget) 可以为设计人员提供有用的指引，而 [性能预算计算器](http://www.performancebudget.io/) 和 [Browser Calories ](https://browserdiet.com/calories/) 里都可以帮助创建预算（感谢 [Karolina Szczur](https://medium.com/@fox/talk-the-state-of-the-web-3e12f8e413b3) 提供）。\n\n\n![ [Brad Frost 构建的性能预算](http://bradfrost.com/blog/post/performance-budget-builder/)](https://user-gold-cdn.xitu.io/2018/2/28/161db9ea3537c803?w=2000&h=1137&f=jpeg&s=53251)\n\n除了性能外，还要考虑对你业务最有利的客户的行为。 设置和讨论**关键行动的可接受时间阈值**，并设置一个整个团队已经达成一致的 “UX ready”用户时间标记。 大部分情况下，用户的行为涉及许多不同部门，因此，按照设置的可接受的时间安排会避免很多问题。确保额外的资源和功能的额外成本其他成员都是可见和知晓的。\n\n此外，正如 Patrick Meenan 所建议的那样，**最好在设计的过程中设置一个加载队列并且要知道这些顺序会存在哪些利弊**。你需要优先处理更重要的优先级，并且定义一个它们优先级的顺序，你也应该清楚哪些是可以推迟的。理想的情况，该队列也应该反映出 JS 和 CSS 的加载顺序，只要设计好了，那么在构建过程中处理它们就会很简单了。另外，还需要考虑的是在页面还在加载时页面的“中间状态”（例如，当 web 字体没有加载完时）。\n\n计划计划计划，重要的事情说三遍！如果早期进行优化那么会很容易实现目标，但是没有计划或者没有制定切合实际的、为公司量身定制的业绩目标那么就很难保持性能。\n\n3. 选择正确的度量\n\n[不是所有的度量都一样重要](https://speedcurve.com/blog/rendering-metrics/)。 研究哪些度量对于你的应用程序最重要：通常，这与你能够以多快的速度开始渲染**最重要**的像素（以及它们的效果）以及如何为这些渲染像素提供输入最快的响应速度有关。 这可以帮助你为后续的工作提供最佳的优化结果。 不管怎样，不要专注于整个页面加载时间（例如 `onLoad` 和 `DOMContentLoaded` 时间），而是要优先按照用户可以感知到的页面加载。 也就是说要关注一组稍微不同的度量。 \n\n\n<iframe src=\"https://player.vimeo.com/video/249524245\" width=\"640\" height=\"358\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\n\n\n\n\n[首次有内容渲染，视觉完整和可交互时间之间的区别](https://docs.google.com/presentation/d/1D4foHkE0VQdhcA5_hiesl8JhEGeTDRrQR4gipfJ8z7Y/present?slide=id.g21f3ab9dd6_0_33)。来自于：[@denar90](https://docs.google.com/presentation/d/1D4foHkE0VQdhcA5_hiesl8JhEGeTDRrQR4gipfJ8z7Y/present?slide=id.g21f3ab9dd6_0_33)\n\n你可以参考下面这样度量：\n\n* **首次有效渲染**（FMP，是指主要内容出现在页面上所需的时间），\n* **[重要渲染时间](https://speedcurve.com/blog/web-performance-monitoring-hero-times/)**（页面最重要部分渲染完成所需的时间），\n* **可交互时间**（TTI，是指页面布局已经稳定，关键的页面字体已经可见，主进程可以足够的处理用户的输入 —— 基本的时间标记是，用户可以在 UI 上进行点击和交互），\n* **输入响应**，接口响应用户操作所需的时间，\n* **Speed Index**，测量填充页面内容的速度。 分数越低越好，\n* [自定义度量](https://speedcurve.com/blog/user-timing-and-custom-metrics/)，由你的业务需求和用户体验来决定。\n\nSteve Souders 对 [每个度量都进行了详细的解释](https://speedcurve.com/blog/rendering-metrics/)。在许多情况下，根据你的应用程序的使用场景，[可交互时间和输入响应](https://medium.com/netflix-techblog/crafting-a-high-performance-tv-user-interface-using-react-3350e5a6ad3b) 会是最关键的。但这些度量可能会不同：例如，对于 Netflix 电视的用户界面来说，关键输入响应、内存使用和可交互时间更为重要。\n\n4. **从具有代表性的用户使用的设备收集数据**\n\n为了收集准确的数据，我们需要尽可能全的选择要测试的设备。最好是 Moto G4，或者一款中档的三星设备又或者是一个 Nexus 5X 这样的普通的设备。如果你手边没有设备，可以使用节流 CPU（5× 减速）来限制网速（例如，150 ms 的往返时延，1.5 Mbps 以下和0.7 Mbps 以上）实现在桌面设备上模拟移动设备的体验。最终，切换到常规的 3G，4G 和 Wi-Fi。为了使性能体验的影响更明显，你甚至可以使用 [2G ](https://www.theverge.com/2015/10/28/9625062/facebook-2g-tuesdays-slow-internet-developing-world) 或 [一个节流的 3G 网络](https://twitter.com/thommaskelly/status/938127039403610112)，以便进行更快的测试。\n\n[![因为周二是一周中最慢的一天。Facebook推出了[2G Tuesdays](https://www.theverge.com/2015/10/28/9625062/facebook-2g-tuesdays-slow-internet-developing-world)，以提高对低速连接的能见度和灵敏度。（[图片来源](http://www.businessinsider.com/facebook-2g-tuesdays-to-slow-employee-internet-speeds-down-2015-10?IR=T)）](https://user-gold-cdn.xitu.io/2018/2/28/161db9ea4540fb71?w=400&h=400&f=png&s=4116)](https://www.theverge.com/2015/10/28/9625062/facebook-2g-tuesdays-slow-internet-developing-world)\n\n幸运的是，有很多优秀的选项可以帮助你自动收集数据，并根据这些度量衡量你的网站在一段时间内的性能。 请记住，良好的性能度量是需要被动和主动监控工具的组合：\n\n\n* **被动监测工具，**可以根据请求来模拟用户交互（**综合测试**，如**Lighthouse**，**WebPageTest**）\n* **主动监测工具，** 是那些不断记录和评价用户交互行为的（**真正的用户监控**，如 **SpeedCurve**，**New Relic**  ——   这两种工具也提供综合测试）\n\n前者在开发过程中特别有用，因为它可以在使用产品时持续跟踪。 后者在长期维护非常有用，因为它可以帮助你了解在实际访问站点时发生的性能瓶颈。通过使用导航定时、资源定时、绘图定时、长时间任务等内置的 RUM API，被动和主动性能监视工具一起提供应用程序性能的完整画面。 例如，你可以使用[PWMetrics](https://github.com/paulirish/pwmetrics)，[Calibre](https://calibreapp.com)，[SpeedCurve](https://speedcurve.com/)，[mPulse](https://www.soasta.com/performance-monitoring/)，[Boomerang](https://github.com/yahoo/boomerang) 和 [Sitespeed.io](https://www-origin.sitespeed.io/)，这些都是性能监测工具的绝佳选择。\n\n注意：选择浏览器外部的网络级别的限制器总是比较安全的，例如 DevTools 由于实现的方式而存在与 HTTP/2 推送交互的问题（感谢Yoav！）。\n\n[![[Lighthouse](https://developers.google.com/web/tools/lighthouse/)一个集成在 DevTools 的性能检测工具。\n](https://user-gold-cdn.xitu.io/2018/2/28/161db9ea352b6e75?w=400&h=274&f=png&s=23160)](https://developers.google.com/web/tools/lighthouse/)\n\n5. **与你的同事分享性能清单**\n\n为了避免误解，要确保你团队里的每个同事都对清单很熟悉。每个决策都对性能有影响。项目将极大地受益于前端开发人员正确地将性能价值传达给整个团队。从而使每个人都对它负责，而不仅仅是前端开发人员。根据绩效预算和清单中定义的优先顺序来设计决策。\n\n[![[RAIL](https://developers.google.com/web/fundamentals/performance/rail)，以用户为中心的性能模型。](https://user-gold-cdn.xitu.io/2018/2/28/161db9ea489e8e90?w=400&h=145&f=png&s=3686)](https://developers.google.com/web/fundamentals/performance/rail)\n\n### 制定现实的目标\n6. **控制响应时间在 100ms 内，控制帧速在 60 帧/秒**\n\n为了让交互感觉起来很顺畅，接口有 100ms 来响应用户的输入。任何比它长的时间，用户都会认为该应用程序很慢。[RAIL，一个以用户为中心的性能模型](https://www.smashingmagazine.com/2015/10/rail-user-centric-model-performance/)会为你提供健壮的目标。为了让页面达到小于 100ms 的响应，页面必须要在小于 50ms 前最迟将控制权返回给主线程。[预计输入延迟时间](https://developers.google.com/web/tools/lighthouse/audits/estimated-input-latency) 告诉我们，如果我们能达到这个门槛，在理想情况下，它应该低于 50ms。对于像动画这样性能消耗比较大的地方，最好的做法是，在能够优化的地方，尽量优化到极致；在不能优化的地方，让性能开销降至最低。\n\n同时，每一帧动画应该要在 16 毫秒内完成，从而达到 60 帧每秒（1秒 ÷ 60 = 16.6 毫秒） —— 最好可以在 10 毫秒完成。因为浏览器需要时间将新框架绘制到屏幕上，你的代码应该在触发 16.6 毫秒以内完成。[保持乐观](https://www.smashingmagazine.com/2016/11/true-lies-of-optimistic-user-interfaces/)和明智地利用空闲时间。显然，这些目标适用于运行时的性能，而不是加载性能。\n\n7. **速度指标(SpeedIndex) < 1250，3G 上交互时间 < 5s，关键文件大小 < 170Kb（SpeedIndex < 1250, TTI < 5s on 3G, Critical file size budget < 170Kb）**\n\n虽然这可能很难实现，一个好的最终目标是首次有效渲染低于 1 秒并且[速度指标](https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index)的值低于 1250。因为我们是以 200 美金为基准的 Android 手机（如 Moto G4）和一个缓慢的 3G 网络上，模拟 400ms 的往返延时和 400kb 的传输速度，所以我们的目标是[可交互时间低于 5s](https://www.youtube.com/watch?v=_srJ7eHS3IM&feature=youtu.be&t=6m21s)，并且再次访问的时间低于 2s。\n\n请注意，当谈到**可交互时间**时，最好来区分一下[首次交互和连续交互](https://calendar.perfplanet.com/2017/time-to-interactive-measuring-more-of-the-user-experience/)以避免对它们之间的误解。前者是在主要内容已经渲染出来后最早出现的点（窗口至少需要 5s，页面才开始响应）。后者是期望页面可以一直进行输入响应的点。\n\nHTML 的前 14~15kb 加载是**是最关键的有效载荷块**  —— 也是第一次往返（这是在400 ms 往返延时下 1 秒内所得到的）预算中唯一可以交付的部分。一般来说，为了实现上述目标，我们必须在关键的文件大小内进行操作。[最高预算压缩之后 170 Kb](https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/)（0.8-1MB解压缩），它已经占用多达 1s （取决于资源类型）来解析和编译。稍微高于这个值是可以的，但是要尽可能地降低这些值。\n\n尽管如此，还是可以提高绑定的规模预算。例如，你可以在浏览器主线程的活动中设置性能预算，例如，在开始渲染前的绘制时间或者[跟踪前端 CPU](https://calendar.perfplanet.com/2017/tracking-cpu-with-long-tasks-api/) 。像 [Calibre](https://calibreapp.com/)，[SpeedCurve](https://speedcurve.com/) 和 [Bundlesize](https://github.com/siddharthkp/bundlesize) 这些工具可以帮助你保持你的预算控制，并集成到你的构建过程。\n\n[![[本来就很快的：现代化加载的最佳实践](https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices) 来自 Addy Osmani（幻灯片 19）](https://user-gold-cdn.xitu.io/2018/2/28/161db9ea471840a1?w=400&h=224&f=png&s=9041)](https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices)\n\n### 定义环境\n8. **做好构建工具的选型以及搭建好（适合自己的）构建工具**\n\n[现如今不要太在意那些很酷的技术栈](https://24ways.org/2017/all-that-glisters/)。根据你的项目使用你的构建工具，无论是 Grunt，Gulp，Webpack，Parcel，还是工具间的组合。只要你能快速的得到结果，并且保证你的构建过程没问题。那么，你就可以选择该构建工具。\n\n9. **渐进式增强**\n\n安全的选择是将 [渐进式增强](https://www.aaron-gustafson.com/notebook/insert-clickbait-headline-about-progressive-enhancement-here/) 作为前端架构和项目部署的指导原则。首先设计和构建核心体验，然后为有能力的浏览器使用高级特性增强体验，创造 [弹性](https://www.aaron-gustafson.com/notebook/insert-clickbait-headline-about-progressive-enhancement-here/) 体验。如果你的网站是在一个网络不佳的并且有个糟糕的显示屏上糟糕的浏览器上运行，速度还很快的话，那么，当它运行在一个快速网络下快速的浏览器的机器上，它只会运行得更快。\n\n10. **选择一个强大的性能基准**\n\n有这么多未知因素影响加载 —— 网络、热保护、缓存回收、第三方脚本、解析器阻塞模式、磁盘的读写、IPC jank、插件安装、CPU、硬件和内存限制、L2/L3缓存、RTTS、图像、Web字体加载行为的差异 —— [JavaScript 的代价是最大的](https://youtu.be/_srJ7eHS3IM?t=3m2s)，web 字体阻塞默认渲染和图片的加载消耗了大量的内存。随着性能瓶颈从 [服务器端转移到客户端](https://calendar.perfplanet.com/2017/tracking-cpu-with-long-tasks-api/)，作为开发人员，我们必须更仔细地考虑所有这些未知因素。\n\n在 170kb 的预算中，已经包括了关键路径的 HTML / CSS / JavaScript、路由器、状态管理、实用程序、框架和应用程序逻辑，我们必须彻底[检查网络传输成本，解析/编译时间和运行时间来选择我们的框架](https://www.twitter.com/kristoferbaxter/status/908144931125858304)。\n\n[![[现代化加载的最佳实践](https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices)来自 Addy Osmani(幻灯片18、19)。](https://user-gold-cdn.xitu.io/2018/2/28/161db9ea338362e7?w=400&h=225&f=png&s=5935)](https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices)\n\n正如 Seb Markbage 所 [指出的](https://twitter.com/sebmarkbage/status/829733454119989248)，测量框架的启动成本的好方法是首先渲染视图，再删除它，然后再渲染，因为它可以告诉你框架是如何扩展的。\n\n第一次渲染倾向于预热一堆编译迟缓的代码，当它扩展时，更大的分支可以从中受益。第二次渲染基本上是仿效页面上的代码重用是如何随着页面复杂度的增长来影响性能特征。\n\n[并不是每个项目都需要框架](https://twitter.com/jaffathecake/status/923805333268639744)。事实上，某些项目 [可以完全移除某些框架并从中受益](https://twitter.com/jaffathecake/status/925320026411950080)。一旦选择了一个框架，你最少会使用好几年。所以，如果你需要使用它，确保你的选择是经过[深思熟虑的](https://medium.com/@ZombieCodeKill/choosing-a-javascript-framework-535745d0ab90#.2op7rjakk) 并且 [对其完全了解](https://www.youtube.com/watch?v=6I_GwgoGm1w)。在进行选择前，至少要考虑总大小的成本 + 初始解析时间：轻量级的选项像 [Preact](https://github.com/developit/preact)，[Inferno](https://github.com/infernojs/inferno)，[Vue](https://vuejs.org/)，[Svelte](https://svelte.technology/) 或者 [Polymer](https://github.com/Polymer/polymer) 都做得很好。框架的大小基线将为你的应用程序代码定义约束条件。。\n\n[![JavaScript 解析成本可能有很大差异。[现代化加载的最佳实践](https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices) 来自Addy Osmani (幻灯片 10)。](https://user-gold-cdn.xitu.io/2018/2/28/161db9eaf5239ccc?w=400&h=224&f=png&s=9389)](https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices)\n\n\n请记住，在移动设备上，与台式计算机相比，预计速度会有 4-5 倍的下降。因为移动设备的 GPU、CPU、内存及电池特性都不同。在手机上的解析时间[比桌面设备的要高 36%](https://github.com/GoogleChromeLabs/discovery/issues/1)。所以总在一个最能代表普遍用户的[平均的设备上测试](https://www.webpagetest.org/easy-load)。\n\n不同的框架将会对性能产生不同的影响，并且需要不同的优化策略。因此，你必须清楚地了解你所依赖的框架的所有细节。当创建一个 web 应用的时候，参考 [PRPL 模式](https://developers.google.com/web/fundamentals/performance/prpl-pattern/) 和 [应用程序 shell 体系结构](https://developers.google.com/web/updates/2015/11/app-shell)。这个想法很简单: 用最少的代码来将初始路由的交互快速呈现，然后使用 service worker 进行缓存和预缓存资源，然后使用懒加载异步加载所需的路由。\n\n[![PRPL Pattern in the application shell architecture](https://user-gold-cdn.xitu.io/2018/2/28/161db9eb007722c6?w=400&h=216&f=png&s=5822)](https://developers.google.com/web/fundamentals/performance/prpl-pattern/)\n\n[PRPL](https://developers.google.com/web/fundamentals/performance/prpl-pattern/) 代表的是保持推送关键资源，渲染初始路由，预缓存剩余路由和延迟加载必要的剩余路由。\n\n[![Application shell architecture](https://user-gold-cdn.xitu.io/2018/2/28/161db9eb044bb892?w=400&h=295&f=png&s=22708)](https://developers.google.com/web/updates/2015/11/app-shell)\n\n[应用程序 shell](https://developers.google.com/web/updates/2015/11/app-shell) 是最小的 HTML、CSS 和 JavaScript 驱动的用户界面。\n\n\n11. **你的项目需要使用 AMP 和 Instant Articles 么？**\n\n译者注:AMP 即加速移动页面，是一种制作可快速加载的轻量型网页的方法，特别适合于移动设备。\n\n依赖于你的组织优先级和战略，你可以考虑使用谷歌的 [AMP](https://www.ampproject.org/) 和 Facebook 的 [Instant Articles](https://instantarticles.fb.com/) 或者苹果的 [Apple News](https://www.apple.com/news/)。如果不使用它们，你也可以实现很好的性能，但是 AMP 确实提供了一个免费的内容分发网络（CDN）的性能框架，而 Instant Articles 将提高你在 Facebook 上的知名度和表现。\n\n对于用户而言，这些技术主要的优势是确保性能，所以有时他们更喜欢 AMP-/Apple News/Instant Pages 链接，而不是“常规”和潜在的臃肿页面。对于那些以内容为主的网站，主要处理很多第三方法内容，这些选择极大地加速渲染的时间。\n\n对于站长而言，这些样式在各个平台可发现性并且 [增强在搜索引擎中的可见性](https://ethanmarcotte.com/wrote/ampersand/)。你也可以重新使用 AMP 作为你的 PWA 数据源来构建[渐进的 Web AMPs](https://www.smashingmagazine.com/2016/12/progressive-web-amps/)。有什么缺点呢？显然，在一个有围墙的区域里，开发者可以创造并维持与内容分离的单独版本，防止 Instant Articles 和 Apple News [没有实际的URLs](https://www.w3.org/blog/TAG/2017/07/27/distributed-and-syndicated-content-whats-wrong-with-this-picture/)。（**谢谢，Addy，Jeremy**）\n\n12. **合理使用 CDN**\n\n根据你拥有的动态数据量，你可以将部分内容外包给[静态站点生成工具](https://www.smashingmagazine.com/2015/11/static-website-generators-jekyll-middleman-roots-hugo-review/) 如 Jekyll、Hexo 生成的静态文件，接着把静态文件推到 CDN  中，最后 CDN 只是提供静态文件的静态版本。所以这样就可以避免发起对数据库的读写请求。你甚至可以选择一个基于 CDN 的[静态主机平台](https://www.smashingmagazine.com/2015/11/modern-static-website-generators-next-big-thing/)，(这样就可以)通过给页面添加可交互组件的方式来丰富你的页面，并以此作为性能提升的标志 ([JAMStack](https://jamstack.org/))。\n\n请注意，CDN 也是可以托管并卸载（offload）动态内容的，所以咱们没有必要把 CDN 的服务范围限定在静态资源。（另外需要你记住的是），不管你的 CDN 是否执行内容压缩（GZip）、内容转换、HTTP/2 传输以及 ESI（一种标记语言，可以用它把网页划分为单独的可缓存的实体）等操作，我们还是需要复核上述操作的，这是因为上述操作不仅会在 CDN 的 edge 处（服务器最接近用户的地方）聚合页面中的静态以及动态内容，也还会执行其它任务。\n\n### 构建优化\n\n13. **分清轻重缓急**\n\n你应该知道优先处理什么。运行你所有静态资源（JavaScript、图片、字体、第三方脚本和页面中“昂贵的”模块，比如：轮播图、复杂的图表和多媒体内容），并将它们划分成组。\n\n先搞清楚资源（assets）可以分为几类，大致可以分为：\n- 针对传统的浏览器，定义基本的**核心**功能（比如：完全可访问的核心内容）\n- 针对多功能浏览器**提升**功能（比如：丰富多彩的，完美的体验）\n- 其他资源（不是绝对需要而且可以被延迟加载的资源，如 Web 字体、不必要的样式、旋转木马脚本、视频播放器、社交媒体按钮、大型图像）\n\n我们在“[Improving Smashing Magazine's Performance](https://www.smashingmagazine.com/2014/09/improving-smashing-magazine-performance-case-study/)”上发布了一篇文章，上面详细描述了该方法。\n\n14. **考虑使用“cutting-the-mustard”模式**\n\n虽然这个技术已经很老了，但我们仍然可以使用 [cutting-the-mustard 技术](http://responsivenews.co.uk/post/18948466399/cutting-the-mustard) 使传统浏览器使用核心功能并增强对现代浏览器的体验。严格限制加载的资源：优先加载核心功能，然后是提升的，最后是其他的。注意：该技术可以从浏览器版本中推断出设备功能，而现在我们已经不再这样做了。\n\n例如：在发展中国家，廉价的安卓手机主要运行 Chrome，他们的内存和 CPU 有限。[PRPL 模式](https://developers.google.com/web/fundamentals/performance/prpl-pattern/) 就是一个好的选择。最终，使用 [Device Memory Client Hints Header](https://github.com/w3c/device-memory)，我们就能够更可靠地识别出低端设备。现在，只有在 Blink 中才支持 header （Blink 支持[client hints](https://caniuse.com/#search=client%20hints)）。因为设备存储也有一个在 [Chrome 中可以调用的](https://developers.google.com/web/updates/2017/12/device-memory) JavaScript API，一种选择是基于 API 的特性检测，只在不支持的情况下回退到“符合标准”技术（**谢谢，Yoav！**）。\n\n15. **减少解析JavaScript 的成本**\n\n当我们处理单页面应用时，在你的页面渲染之前你需要初始化应用。寻找模块和技术加快初始化渲染时间（例如：[如何调试 React 性能](https://building.calibreapp.com/debugging-react-performance-with-react-16-and-chrome-devtools-c90698a522ad)，以及[如何提高 Angular 性能](https://www.youtube.com/watch?v=p9vT0W31ym8)），因为大多数性能问题来自于启动应用程序的初始解析时间。\n\n[JavaScript 有成本](https://youtu.be/_srJ7eHS3IM?t=9m33s)，但不一定是文件大小影响性能。解析和执行时间的不同很大程度依赖设备的硬件。在一个普通的手机上（Moto G4），仅解析 1MB （未压缩的）的 JavaScript 大概需要 1.3-1.4 秒，会有 15 - 20% 的时间耗费在手机的解析上。在执行编译过程中，只是用在 JavaScript 准备平均需要 4 秒，在手机上页面展示其主要内容所需的时间（First Meaningful Paint）需要 11 秒。解释：在低端移动设备上，[解析和执行时间可以轻松提高 2 至 5 倍](https://medium.com/reloading/javascript-start-up-performance-69200f43b201)。\n\nEmber 最近做了一个实验，使用[二进制模板（binary templates ）](https://emberjs.com/blog/2017/10/10/glimmer-progress-report.html#toc_binary-templates)巧妙的避免解析开销的方式。这些模板不需要解析。（**感谢，Leonardo！**）\n\n这就是检查每个 JavaScript 依赖性的关键，像 [webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)、[Source Map Explorer](https://github.com/danvk/source-map-explorer) 和 [Bundle Buddy](https://github.com/samccone/bundle-buddy) 这样的工具可以帮助你完成这些。[度量 JavaScript 解析和编译时间](https://medium.com/reloading/javascript-start-up-performance-69200f43b201#7557)。Etsy 的 [DeviceTiming](https://github.com/danielmendel/DeviceTiming)，一个小工具可以让你的 JavaScript 测量任何设备或浏览器上的解析和执行时间。重要的是，虽然文件的大小重要，但它不是最重要的。解析和编译时间并不是随着脚本大小增加而[线性增加](https://medium.com/reloading/javascript-start-up-performance-69200f43b201)。\n\n<iframe src=\"https://player.vimeo.com/video/249525818\" width=\"640\" height=\"384\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\n\n[Webpack Bundle Analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer) visualizes JavaScript dependencies.\n\n\n\n16. **你使用 ahead-of-time 编译器么？**\n\n使用 [ahead-of-time 编译器](https://www.lucidchart.com/techblog/2016/09/26/improving-angular-2-load-times/) 来 [减轻从客户端](https://www.smashingmagazine.com/2016/03/server-side-rendering-react-node-express/) 到 [服务端的渲染](http://redux.js.org/docs/recipes/ServerRendering.html) 的开销，因此快速输出有用的结果。最后，考虑使用 [Optimize.js](https://github.com/nolanlawson/optimize-js) 通过包装可快速调用的函数来实现(在app初始时能够)快速载入（尽管，它[可能不需要](https://twitter.com/tverwaes/status/809788255243739136)）。\n\n17. **你使用 tree-shaking、scope hoisting、code-splitting 么**\n\n[Tree-shaking](https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf) 是一种清理构建过程的方法通过只加载生产中实际使用的代码并清除 [在 Webpack 中](http://www.2ality.com/2015/12/webpack-tree-shaking.html) 未使用的 `import`。使用 Webpack 3 和 Rollup，我们还可以使用 [scope hoisting(作用域提升)](https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f)，`scope hoisting` 允许工具检测哪些 `import` 可以被提升或者可以转换成一个内联函数。有了 Webpack 4，你现在可以使用 [JSON Tree Shaking](https://react-etc.net/entry/json-tree-shaking-lands-in-webpack-4-0)。[UnCSS](https://github.com/giakki/uncss) 或者 [Helium](https://github.com/geuis/helium-css) 可以帮助你去删除未使用 CSS 样式。\n\n而且，你需要考虑 [如何编写有效的 CSS 选择器](http://csswizardry.com/2011/09/writing-efficient-css-selectors/) 以及 [如何避免编写臃肿和开销浪费的样式](https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/)。你也可以使用 Webpack 缩短类名和在编译时使用独立作用域来 [动态地重命名 CSS 类](https://medium.freecodecamp.org/reducing-css-bundle-size-70-by-cutting-the-class-names-and-using-scope-isolation-625440de600b)\n\n[Code-splitting](https://webpack.github.io/docs/code-splitting.html) 是 Webpack 的另一个特性，可将你的代码分解为按需加载的“块”。并不是所有的 JavaScript 都是必须下载、解析和编译的。一旦你在代码中确定了分割点，Webpack 会处理这些依赖关系和输出文件。在应用发送请求的时候，这样基本上确保初始的下载足够小并且实现按需加载。另外，考虑使用 [preload-webpack-plugin](https://github.com/GoogleChromeLabs/preload-webpack-plugin) 获取代码拆分的路径，然后使用 `<link rel=\"preload\">` or `<link rel=\"prefetch\">` 提示浏览器预加载它们。\n\n在哪里定义分离点？通过追踪哪些 CSS/JavaScript 块被使用和哪些没有被使用。Umar Hansa [解释了](https://vimeo.com/235431630#t=11m37s)你如何使用 Devtools 的 Code Coverage 来实现。\n\n如果你没有使用 Webpack，那么相比于 Browserify 的输出结果， [Rollup](http://rollupjs.org/) 的输出更好一些。当使用 Rollup 时，推荐你了解下 [Rollupify](https://github.com/nolanlawson/rollupify)，它可以将 ECMAScript 2015 modules 转化为一个大的 CommonJS module —— 因为小的模块会有[令人惊讶的高性能开销](https://nolanlawson.com/2016/08/15/the-cost-of-small-modules/)（取决于打包工具和模块加载系统的选择）。\n\n![Addy Osmani 的“默认快速：现代化加载的最佳实践”](https://user-gold-cdn.xitu.io/2018/2/28/161db9eb1a1ab2f1?w=400&h=224&f=png&s=17813)\n\nAddy Osmani 的从[快速默认：现代加载的最佳实践](https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices)。幻灯片76。\n\n最后，随着[现代浏览器](http://kangax.github.io/compat-table/es6/)对 ES2015 支持越来越好，考虑 [使用`babel-preset-env`](http://2ality.com/2017/02/babel-preset-env.html) 只转换现代浏览器不支持的 ES2015+ 的特性。然后[设置两个构建](https://gist.github.com/newyankeecodeshop/79f3e1348a09583faf62ed55b58d09d9)，一个为 ES6 一个为 ES5。我们可以 [使用`script type=\"module\"`](https://matthewphillips.info/posts/loading-app-with-script-module) 让具有 ES 模块浏览器支持加载文件，而老的浏览器可以加载传统的 `script nomodule`。\n\n对于 loadsh，[使用 `babel-plugin-lodash`](https://github.com/lodash/babel-plugin-lodash) 将只加载你仅在源码中使用的模块。这可能会为你节省相当多的 JavaScript 负载。\n\n18. **利用你使用的 JavaScript 引擎对其进行优化**\n\n研究 JavaScript 引擎在用户基础中占的比例，然后探索优化它们的方法。例如，当优化的 V8 引擎是用在 Blink 浏览器，Node.js 运行和 Electron 的时候，对每个脚本使用[脚本流](https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html)。一旦下载开始，它允许 `async` 或 `defer scripts` 在一个单独的后台线程进行解析，因此在某些情况下，提高 10% 的页面加载时间。实际上，在 `<head>` 中 [使用 `<script defer>`](https://medium.com/reloading/javascript-start-up-performance-69200f43b201#3498)，以便 [浏览器更早地可以发现资源](https://medium.com/reloading/javascript-start-up-performance-69200f43b201#3498)，然后在后台线程中解析它。\n\n**Caveat**：**Opera Mini [不支持 defement 脚本](https://caniuse.com/#search=defer)，如果你正在印度和非洲从事开发工作，`defer` 将会被忽略，导致阻塞渲染直到脚本加载（感谢 Jeremy）!**。\n\n[![渐进引导](https://user-gold-cdn.xitu.io/2018/2/28/161db9eb1464952f?w=400&h=191&f=jpeg&s=13384)](https://aerotwist.com/blog/when-everything-is-important-nothing-is/)\n\n[渐进引导](https://aerotwist.com/blog/when-everything-is-important-nothing-is/)：使用服务器端呈现获得首次有效绘制，但也包含一些最小必要的 JavaScript 来保持实时交互来接近首次有效绘制。\n\n19. **客户端渲染还是服务端渲染？**\n\n在两种场景下，我们的目标应该是建立 [渐进引导](https://aerotwist.com/blog/when-everything-is-important-nothing-is/)：使用服务端呈现获得首次有效绘制，而且还要包含一些最小必要的 JavaScript 来**保持实时交互来接近首次有效绘制**。如果 JavaScript 在首次有效绘制没有获取到，那么浏览器可能会在解析时[锁住主线程](https://davidea.st/articles/measuring-server-side-rendering-performance-is-tricky)，编译和执行最新发现的 JavaScript，[从而对站点或应用程序的交互性造成限制](https://philipwalton.com/articles/why-web-developers-need-to-care-about-interactivity/)。\n\n为了避免这样做，总是将执行函数分离成一个个，异步任务和可能用到 `requestIdleCallback` 的地方。考虑 UI 的懒加载部分使用 WebPack [动态 `import` 支持](https://developers.google.com/web/updates/2017/11/dynamic-import)，避免加载、解析和编译开销直到用户真的需要他们（**感谢  Addy!**）。\n\n在本质上，交互时间（TTI）告诉我们导航和交互之间的时间。度量是通过在窗口初始内容呈现后的第一个五秒来定义的，在这个过程中，JavaScript 任务都不超过 50ms。如果发生超过 50ms 的任务，则重新开始搜索五秒钟的窗口。因此，浏览器首先会假定它达到了交互式，只是切换到冻结状态，最终切换回交互式。\n\n一旦我们达到交互式，然后，我们可以按需或等到时间允许，启动应用程序的非必需部分。不幸的是，随着 [Paul Lewis 提到的](https://aerotwist.com/blog/when-everything-is-important-nothing-is/#which-to-use-progressive-booting)，框架通常没有优先级的概念，因此渐进式引导很难用大多数库和框架实现。如果你有时间和资源，使用该策略可以极大地改善前端性能。\n\n20. **你是否限制第三方脚本的影响？**\n\n随着所有性能优化的到位，我们常常无法控制来自业务需求的第三方脚本。第三方脚本的度量不受用户体验的影响，所以，一个单一的脚本常常会以调用令人讨厌的，长长的第三方脚本为结尾，因此，破坏了为性能专门作出的努力。为了控制和减轻这些脚本带来的性能损失，仅异步加载（[可能通过 defer](https://www.twnsnd.com/posts/performant_third_party_scripts.html)）和通过资源提示，如：`dns-prefetch` 或者 `preconnect` 加速他们是不足够的。\n\n正如 Yoav Weiss 在他的[必须关注第三方脚本的通信](http://conffab.com/video/taking-back-control-over-third-party-content/)中解释的，在很多情况下，下载资源的这些脚本是动态的。页面负载之间的资源是变化的，因此我们不知道主机是从哪下载的资源以及这些资源是什么。\n\n这时，我们有什么选择？考虑 **通过一个超时来使用 service workers 下载资源**，如果在特定的时间间隔内资源没有响应，返回一个空的响应告知浏览器执行解析页面。你可以记录或者限制那些失败的第三方请求和没有执行特定标准请求。\n\n另一个选择是建立一个 **内容安全策略（CSP）** 来限制第三方脚本的影响，比如：不允许下载音频和视频。最好的选择是通过 `<iframe>` 嵌入脚本使得脚本运行在 iframe 环境中，因此如果没有接入页面 DOM 的权限，在你的域下不能运行任何代码。Iframe 可以 使用 `sandbox` 属性进一步限制，因此你可以禁止 iframe 的任何功能，比如阻止脚本运行，阻止警告、表单提交、插件、访问顶部导航等等。\n\n例如，它可能必须要允许脚本运行 `<iframe sandbox=\"allow-scripts\">`。每一个限制都可以通过多种允许值在 'sandbox' 属性中（[几乎处处支持](https://caniuse.com/#search=sandbox)）解除，所以将它们限制在允许做的最低限度。考虑使用 [Safeframe](https://github.com/interactiveadvertisingbureau/safeframe) 和 Intersection Observer；这将使广告嵌入 iframe 的同时仍然调度事件或需要从 DOM 获取信息（例如广告知名度）。注意新的策略如 [特征策略](https://wicg.github.io/feature-policy/)）、资源的大小限制、CPU 和带宽优先级限制损害的网络功能和会减慢浏览器的脚本，例如：同步脚本，同步 XHR 请求，document.write 和超时的实现。\n\n要对第三方进行 [压力测试](https://csswizardry.com/2017/07/performance-and-resilience-stress-testing-third-parties/)，在 DevTools 上自底向上概要地检查页面的性能，测试在请求被阻止或超时后会发生什么情况，对于后者，你可以使用 WebPageTest 的 Blackhole 服务器 `72.66.115.13`，你可以在你的 `hosts` 文件中指定特定的域名。最好是[最好是自主主机并使用单个主机名](https://www.twnsnd.com/posts/performant_third_party_scripts.html)，但是同时[生成一个请求映射](https://www.soasta.com/blog/10-pro-tips-for-managing-the-performance-of-your-third-party-scripts/)，当脚本变化时，暴露给第四方调用和检测。\n\n![请求块](https://user-gold-cdn.xitu.io/2018/2/28/161db9eb17714858?w=400&h=238&f=png&s=20877)\n\n[Harry Roberts](https://csswizardry.com/2017/07/performance-and-resilience-stress-testing-third-parties/#request-blocking)\n\n21. **HTTP cache 头部设置是否合理？**\n\n再次检查一遍 `expires`，`cache-control`，`max-age` 和其他 HTTP cache 头部都是否设置正确。通常，资源应该是可缓存的，不管是短时间的（它们是否很可能改变），还是无限期的（它们是否是静态的）。 你可以在需要更新的时候，改变它们 URL 中的版本即可。在任何资源上禁止头部 `Last-Modified` 都会导致一个 `If-Modified-Since` 条件查询，即使资源在缓存中。与 `Etag` 一样，即使它在使用中。\n\n使用 `Cache-control: immutable`，(其实是为了解决fingerprinted静态资源的缓存问题而被设计出来的，解决了客户端revalidation问题（截至 2017年12月，[在 FireFox，Edge 和 Safari 中支持](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)；只有 FireFox 在 HTTPS 中支持）。你也可以使用 [Heroku 的 HTTP 缓存头部](https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers)，Jake Archibald 的 \"[Caching Best Practices](https://jakearchibald.com/2016/caching-best-practices/)\" ，以及 Ilya Grigorik 的 [HTTP caching primer](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en) 作为指导。而且，注意[不同的头部](https://www.smashingmagazine.com/2017/11/understanding-vary-header/)，尤其是[在关系到 CDN 时](https://www.fastly.com/blog/getting-most-out-vary-fastly)，并且注意[并且要注意关键头文件](https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-key-latest.html)，有助于避免在新请求稍有差异时进行额外的验证，但从以前请求标准，并不是必要的（**感谢，Guy！**）。\n\n\n### 静态资源优化\n\n22. **你是否使用 Brotli 或 Zopfli 进行纯文本压缩？**\n\n在 2005 年，[Google 推出了](https://opensource.googleblog.com/2015/09/introducing-brotli-new-compression.html) [Brotli](https://github.com/google/brotli)，一个新的开源无损数据压缩格式，现在已经 [被所有的现代浏览器所支持](http://caniuse.com/#search=brotli)。实际上，Brotli 比 Gzip 和 Deflate [更有效](https://samsaffron.com/archive/2016/06/15/the-current-state-of-brotli-compression)。压缩速度可能会非常慢，取决于设置信息。但是缓慢的压缩过程会提高压缩率，并且仍然可以快速解压。当然，解压缩速度很快。\n\n只有当用户通过 HTTPS 访问网站时，浏览器才会采用。Brotli 现在还不能预装在某些服务器上，而且如果不自己构建 NGINX 和 UBUNTU 的话很难部署。[不过这也并不难](https://www.smashingmagazine.com/2016/10/next-generation-server-compression-with-brotli/)。实际上，[一些 CDN 是支持的](https://community.akamai.com/community/web-performance/blog/2017/08/18/brotli-support-enablement-on-akamai)，甚至 [也可以通过服务器在不支持 CDN 的情况下启用 Brotli](http://calendar.perfplanet.com/2016/enabling-brotli-even-on-cdns-that-dont-support-it-yet/)。\n\n在最高级别的压缩下，Brotli 的速度会变得非常慢，以至于服务器在等待动态压缩资源时开始发送响应所花费的时间可能会使我们对文件大小的优化无效。但是，对于静态压缩，[高压缩比的设置比较受欢迎](https://css-tricks.com/brotli-static-compression/) —— （**感谢 Jeremy!**）\n\n或者，你可以考虑使用 [Zopfli 的压缩算法](https://blog.codinghorror.com/zopfli-optimization-literally-free-bandwidth/)，将数据编码为 Deflate，Gzip 和 Zlib 格式。Zopfli 改进的 Deflate 编码使得任何使用 Gzip 压缩的文件受益，因为这些文件大小比 用Zlib 最强压缩后还要小 3％ 到 8％。问题在于压缩文件的时间是原来的大约 80倍。这就是为什么虽然 使用 Zopfli 是一个好主意但是变化并不大，文件都需要设计为只压缩一次可以多次下载的。\n\n比较好的方法是你可以绕过动态压缩静态资源的成本。Brotli 和 Zopfli 都可以用于明文传输 —— HTML，CSS，SVG，JavaScript 等。\n\n有什么方法呢？在最高等级和 Brotli 的 1-4 级动态压缩 HTML 使用 Brotli+Gzip 预压缩静态资源。同时，检查 Brotli 是否支持 CDN，（例如 **KeyCDN，CDN77，Fastly**）。确保服务器能够使用 Brotli 或 gzip 处理内容。如果你不能安装或者维护服务器上的 Brotli，那么请使用 Zopfli。\n\n23. **图像是否进行了适当的优化？**\n\n尽可能通过 `srcset`，`sizes` 和 `<picture>` 元素使用 [响应式图片](https://www.smashingmagazine.com/2014/05/responsive-images-done-right-guide-picture-srcset/)。也可以通过 `<picture>` 元素使用 WebP 格式的图像（Chrom，Opera，[Firefox soon](https://bugzilla.mozilla.org/show_bug.cgi?id=1294490)支持），或者一个 JPEG 的回调（见 Andreas Bovens 的 [code snippet](https://dev.opera.com/articles/responsive-images/#different-image-types-use-case)）或者通过使用内容协商（使用 `Accept` 头信息）。\n\nSketch 本身就支持 WebP 并且 WebP 图像可以通过使用 [WebP 插件](http://telegraphics.com.au/sw/product/WebPFormat#webpformat) 从 PhotoShop 中导出。也有其他选择可以使用，如果你使用 WordPress 或者 Joomla，也有可以轻松支持 WebP 的扩展，例如 [Optimus](https://wordpress.org/plugins/optimus/) 和 [Cache Enabler](https://wordpress.org/plugins/cache-enabler/)（通过 [Cody Arsenault](https://css-tricks.com/comparing-novel-vs-tried-true-image-formats/)）\n\n你可以仍然使用 [client hints](https://www.smashingmagazine.com/2016/01/leaner-responsive-images-client-hints/)，但仍需要获得一些浏览器支持。没有足够的资源支持响应式图片？使用 [断点发生器](http://www.responsivebreakpoints.com/) 或者类似 [Cloudinary](http://cloudinary.com/documentation/api_and_access_identifiers) 这样的服务自动优化图片。同样，在许多情况下，只使用 `srcset` 和 `sizes` 会有不错的效果。\n\n[![响应图像断点发生器](https://user-gold-cdn.xitu.io/2018/2/28/161db9ebbae11df1?w=400&h=229&f=jpeg&s=19729)](http://www.responsivebreakpoints.com/)\n\n[响应图像断点生成器](http://www.responsivebreakpoints.com/)自动生成图像和标记生成。\n\n\n24. **图片优化进阶别**\n\n现在有一个至关重要着陆页，有一个特定的图片的加载速度非常关键，确保 JPEGs 是渐进式的并且使用 [Adept](https://github.com/technopagan/adept-jpg-compressor)、 [mozJPEG](https://github.com/mozilla/mozjpeg) （通过操纵扫描级来改善开始渲染时间）或者 [Guetzli](https://github.com/google/guetzli) 压缩，谷歌新的开源编码器重点是能够感官的性能，并借鉴 Zopfli 和 WebP。唯一的 [不足](https://medium.com/@fox/talk-the-state-of-the-web-3e12f8e413b3) 是：处理的时间慢（每百万像素 CPU 一分钟）。至于 png，我们可以使用 [Pingo](http://css-ig.net/pingo)，和 [svgo](https://www.npmjs.com/package/svgo)，对于 SVG 的处理，我们使用 [SVGO](https://www.npmjs.com/package/svgo) 或 [SVGOMG](https://jakearchibald.github.io/svgomg/)\n\n每一个图像优化的文章会说明，但始终会提醒要保持矢量资源干净和紧密。确保清理未使用的资源，删除不必要的元数据，并减少图稿中的路径点数量（从而减少SVG代码）。（**感谢，Jeremy！**）\n\n到目前为止，这些优化只涵盖了基础知识。 Addy Osmani 已经发布了 [一个非常详细的基本图像优化指南](https://images.guide/)，深入到图像压缩和颜色管理的细节。 例如，您可以模糊图像中不必要的部分（通过对其应用高斯模糊滤镜）以减小文件大小，最终甚至可以开始移除颜色或将图像变成黑白色，以进一步缩小图像尺寸。 对于背景图像， 从Photoshop 导出的照片质量为 0 到 10％ 也是绝对可以接受的。\n\n那么 GIF 图片呢？我们可以使用 [循环的 HTML5 视频](https://bitsofco.de/optimising-gifs/)，而不是影响渲染性能和带宽的重度 GIF 动画，而使用循环的 HTML5 视频，虽然 [`<video>`](https://calendar.perfplanet.com/2017/animated-gif-without-the-gif/#-but-we-already-have-video-tags) 会使得 [浏览器的性能很慢](https://calendar.perfplanet.com/2017/animated-gif-without-the-gif/#-but-we-already-have-video-tags)，但是与图像不同的是，浏览器不会预先加载 `<video>` 内容。我们也可以使用 [Lossy GIF](https://kornel.ski/lossygif), [gifsicle](https://github.com/kohler/gifsicle) 或者 [giflossy](https://github.com/pornel/giflossy) 添加有损压缩 GIF。\n\n[好](https://developer.apple.com/safari/technology-preview/release-notes/) [消息](https://bugs.chromium.org/p/chromium/issues/detail?id=791658): 希望不久以后我们可以使用 `<img src=\".mp4\">` 来加载视频, 早期的测试表明 `img` 标签比同等大小的 GIF [显示速度的要快 20 多倍，解析速度要快 7 倍多](https://calendar.perfplanet.com/2017/animated-gif-without-the-gif/)。\n\n还不够好？那么，你也可以使用 [多个](http://csswizardry.com/2016/10/improving-perceived-performance-with-multiple-background-images/)[背景](https://jmperezperez.com/medium-image-progressive-loading-placeholder/)[图像](https://manu.ninja/dominant-colors-for-lazy-loading-images#tiny-thumbnails)[技术](https://css-tricks.com/the-blur-up-technique-for-loading-background-images/) 提高图像的感知性能。 记着，[减少对比度](https://css-tricks.com/contrast-swap-technique-improved-image-performance-css-filters/)  和模糊不必要的细节（或消除颜色）也可以减小文件的大小。 你需要放大一个小照片而不失真？考虑使用 [Letsenhance.io](https://letsenhance.io)\n\n![Zach Leatherman 的字体加载策略综合指南](https://user-gold-cdn.xitu.io/2018/2/28/161db9ebc446bcf5?w=400&h=243&f=png&s=4932)\n\nZach Leatherman 的 [字体加载策略综合指南](https://www.zachleat.com/web/comprehensive-webfonts/) 提供了十几种更好的网页字体发送选项\n\n25. **是否对 Web字体进行了优化？**\n\n首先需要问一个问题，你是否能不使用 [UI 系统字体](https://www.smashingmagazine.com/2015/11/using-system-ui-fonts-practical-guide/)。 如果不可以，那么你有很大可能使用 Web 网络字体，会包含字形和额外的功能以及用不到的加粗。你可以向字体设计公司获取网络字体子集或子集，如果您使用的是开源字体（例如，通过仅包含带有某些特殊的重音字形的拉丁语），则可以只选择部分 Web 字体来减少其文件大小。\n\n[WOFF2](http://caniuse.com/#search=woff2)  的支持非常好，对于不支持WOFF2的浏览器，你可以使用 WOFF 和 OTF 作为不支持它的浏览器的备选。另外，从 Zach Leatherman 的《[字体加载策略综合指南](https://www.zachleat.com/web/comprehensive-webfonts/)》（代码片段也可以作为 [Web字体加载片段](https://github.com/zachleat/web-font-loading-recipes)）中选择一种策略，并使用服务器缓存持久地缓存字体。是不是感觉小有成就？Pixel Ambacht 有一个 [快速教程和案例研究](https://pixelambacht.nl/2016/font-awesome-fixed/)，让你的字体按顺序排列。\n\n如果你无法从你的服务器拿到字体并依赖于第三方主机，请确保使用 [字体加载事件](https://www.igvita.com/2014/01/31/optimizing-web-font-rendering-performance/#font-load-events)（或对不支持它的浏览器使用 [Web字体加载器](https://github.com/typekit/webfontloader)）[FOUT 要优于 FOIT](https://www.filamentgroup.com/lab/font-events.html); 立即开始渲染文本，并异步加载字体 —— 也可以使用 [loadCSS](https://github.com/filamentgroup/loadCSS)。 你也可以 [摆脱本地安装的操作系统字体](https://www.smashingmagazine.com/2015/11/using-system-ui-fonts-practical-guide/)，也可以使用 [可变的](https://alistapart.com/blog/post/variable-fonts-for-responsive-design) [字体](https://www.smashingmagazine.com/2017/09/new-font-technologies-improve-web/)。\n\n怎么才能是一个无漏洞的字体加载策略？ 从 `font-display` 开始，然后到 Font Loading API，**然后**到 Bram Stein 的 [Font Face Observer](https://github.com/bramstein/fontfaceobserver)（**感谢 Jeremy！**）如果你有兴趣从用户的角度来衡量字体加载的性能， Andreas Marschke 探索了 [使用 Font API 和 UserTiming API 进行性能跟踪](ttps://www.andreas-marschke.name/posts/2017/12/29/Fonts-API-UserTiming-Boomerang.html)\n\n此外，不要忘记包含 [`font-display：optional`](https://font-display.glitch.me/) 描述符来提供弹性和快速的字体回退，[`unicode-range`](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2015/august/how-to-subset-fonts-with-unicode-range/) 将大字体分解成更小的语言特定的字体，以及Monica Dinculescu [的字体样式匹配器](https://meowni.ca/font-style-matcher/) 用来解决由于两种字体之间的大小差异，最大限度地减少了布局上的震动的问题。\n\n\n### 交付优化\n\n26. **你是否异步加载 JavaScript？**\n\n当用户请求页面时，浏览器获取 HTML 并构造 DOM，然后获取 CSS 并构造 CSSOM，然后通过匹配 DOM 和 CSSOM 生成一个渲染树。如果有任何的 JavaScript 需要解决，浏览器将不会开始渲染页面，直到 JavaScript 解决完毕，这样就会延迟渲染。 作为开发人员，我们必须明确告诉浏览器不要等待并立即开始渲染页面。 为脚本执行此操作的方法是使用 HTML 中的 `defer` 和 `async` 属性。\n\n事实证明，我们 [应该把 `async` 改为 `defer`](http://calendar.perfplanet.com/2016/prefer-defer-over-async/)（因为 ie9 及以下不支持 async）。 另外，如上所述，限制第三方库和脚本的影响，特别是使用社交共享按钮和嵌入的 `<iframe>` 嵌入（如地图）。 [大小限制](https://github.com/ai/size-limit) 有助于防止 JavaScript 库过大：如果您不小心添加了大量依赖项，该工具将通知你并抛出错误。 你可以使用 [静态社交分享按钮](https://www.savjee.be/2015/01/Creating-static-social-share-buttons/)（如通过 [SSBG](https://simplesharingbuttons.com) ）和 [静态链接](https://developers.google.com/maps/documentation/static-maps/intro) 来代替交互式地图。\n\n27. **你对开销很大的 JS 是否使用懒加载并使用 Intersection Observer？**\n\n如果您需要延迟加载图片、视频、广告脚本、A/B 测试脚本或任何其他资源，则可以使用 [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)，它提供了一种方法异步观察目标元素与 祖先元素或顶层文档的视口。基本上，你需要创建一个新的 IntersectionObserver 对象，它接收一个回调函数和一组选项。 然后我们添加一个目标来观察。\n\n当目标变得可见或不可见时执行回调函数，所以当它拦截视口时，可以在元素变得可见之前开始采取一些行动。 事实上，我们可以精确地控制观察者的回调何时被调用，使用 `rootMargin` 和 `threshold`（一个数字或者一个数字数组来表示目标可见度的百分比）。Alejandro Garcia Anglada 发表了一个 [简单的教程](https://medium.com/@aganglada/intersection-observer-in-action-efc118062366) 关于如何实际实施的教程。\n\n你甚至可以通过向你的网页添加 [渐进式图片加载](https://calendar.perfplanet.com/2017/progressive-image-loading-using-intersection-observer-and-sqip/) 来将其提升到新的水平。 与 Facebook，Pinterest 和 Medium 类似，你可以首先加载低质量或模糊的图像，然后在页面继续加载时，使用 Guy Podjarny 提出的 [LQIP (Low Quality Image Placeholders) technique](https://www.guypo.com/introducing-lqip-low-quality-image-placeholders/)（低质量图像占位符）技术替换它们的清晰版本。（可以参考知乎）\n\n如果技术提高了用户体验，观点就不一样了，但它肯定会提高第一次有意义的绘画的时间。我们甚至可以通过使用 [SQIP](https://github.com/technopagan/sqip) 创建图像的低质量版本作为 SVG 占位符来实现自动化。 这些占位符可以嵌入 HTML 中，因为它们自然可以用文本压缩方法压缩。 Dean Hume 在他的文章中 [描述了](https://calendar.perfplanet.com/2017/progressive-image-loading-using-intersection-observer-and-sqip/) 如何使用 Intersection Observer 来实现这种技术。\n\n浏览器支持程度如何呢？[Decent](https://caniuse.com/#feat=intersectionobserver)，与 Chrome，火狐，Edge 和 Samsung Internet 已经支持了。 WebKit 目前 [正在开发中](https://webkit.org/status/#specification-intersection-observer)。如果浏览器不支持呢？ 如果不支持Intersection Observer，我们仍然可以 [延迟加载](https://medium.com/@aganglada/intersection-observer-in-action-efc118062366) 一个 [polyfill](https://github.com/jeremenichelli/intersection-observer-polyfill) 或立即加载图像。甚至还有一个 [library](https://github.com/ApoorvSaxena/lozad.js)。\n\n通常，我们会使用懒加载来处理所有代价较大的组件，如字体，JavaScript，轮播，视频和 iframe。 你甚至可以根据网络质量调整内容服务。[网络信息 API](https://googlechrome.github.io/samples/network-information/)，特别是 `navigator.connection.effectiveType`（Chrome 62+）使用 RTT 和下行链路值来更准确地表示连接和用户可以处理的数据。 您可以使用它来完全删除视频自动播放，背景图片或 Web 字体，以便连接速度太慢。\n\n28. **你是否优先加载关键的 CSS？**\n\n为确保浏览器尽快开始渲染页面，[通常](https://www.smashingmagazine.com/2015/08/understanding-critical-css/) 会收集开始渲染页面的第一个可见部分所需的所有 CSS（称为 “关键CSS” 或 “首屏 CSS”）并将其内联添加到页面的 `<head>` 中，从而减少往返。 由于在慢启动阶段交换包的大小有限，所以关键 CSS 的预算大约是 14 KB。\n\n如果超出这个范围，浏览器将需要额外往返取得更多样式。  [CriticalCSS](https://github.com/filamentgroup/criticalCSS) 和 [Critical](https://github.com/addyosmani/critical) 可以做到这一点。 你可能需要为你使用的每个模板执行此操作。 如果可能的话，考虑使用 Filament Group 使用的 [条件内联方法](https://www.filamentgroup.com/lab/modernizing-delivery.html)。\n\n使用 HTTP/2，关键 CSS 可以存储在一个单独的 CSS 文件中，并通过 [服务器推送](https://www.filamentgroup.com/lab/modernizing-delivery.html) 来传递，而不会增大 HTML 的大小。 问题在于，服务器推送是很 [麻烦](https://twitter.com/jaffathecake/status/867699157150117888)，因为浏览器中存在许多问题和竞争条件。 它一直不被支持，并有一些缓存问题（参见 [Hooman Beheshti介绍的文章]([Hooman Beheshti's presentation](http://www.slideshare.net/Fastly/http2-what-no-one-is-telling-you)) 114 页内容）。事实上，这种影响可能是 [负面的](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)，会使网络缓冲区膨胀，从而阻止文档中的真实帧被传送。 而且，由于 TCP 启动缓慢，似乎服务器推送在热连接上 [更加有效](https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit)。\n\n即使使用 HTTP/1，将关键 CSS 放在根目录上的单独文件中也是有 [好处的](http://www.jonathanklein.net/2014/02/revisiting-cookieless-domain.html)，有时甚至比缓存和内联更为有效。 Chrome 请求这个页面的时候会再发送一个 HTTP 连接到根目录，从而不需要 TCP 连接来获取这个 CSS（**感谢 Philip！**）\n\n需要注意的一点是：和 `preload` 不同的是，`preload` 可以触发来自任何域的预加载，而你只能从你自己的域或你所授权的域中推送资源。 一旦服务器得到来自客户端的第一个请求，就可以启动它。 服务器将资源压入缓存，并在连接终止时被删除。 但是，由于可以在多个选项卡之间重复使用 HTTP/2 连接，所以推送的资源也可以被来自其他选项卡的请求声明（**感谢 Inian！**）。\n\n目前，服务器并没有一个简单的方法得知被推送的资源 [是否已经存在于用户的缓存中](https://blog.yoav.ws/tale-of-four-caches/)，因此每个用户的访问都会继续推送资源。因此，您可能需要创建一个 [缓存监测 HTTP/2 服务器推送机制](https://css-tricks.com/cache-aware-server-push/)。如果被提取，您可以尝试从缓存中获取它们，这样可以避免再次推送。\n\n但请记住，[新的 `cache-digest` 规范](http://calendar.perfplanet.com/2016/cache-digests-http2-server-push/) 无需手动建立这样的 “缓存感知” 的服务器，基本上在 HTTP/2 中声明的一个新的帧类型就可以表达该主机的内容。因此，它对于 CDN 也是特别有用的。\n\n对于动态内容，当服务器需要一些时间来生成响应时，浏览器无法发出任何请求，因为它不知道页面可能引用的任何子资源。 在这种情况下，我们可以预热连接并增加 TCP 拥塞窗口大小，以便将来的请求可以更快地完成。 而且，所有内联配置对于服务器推送都是较好的选择。事实上，Inian Parameshwaran 对 [HTTP/2 Push 和 HTTP Preload 进行了比较 深入的研究](https://dexecure.com/blog/http2-push-vs-http-preload/)，内容很不错，其中包含了您可能需要的所有细节。服务器到底是推送还是不推送呢？你可以阅读一下 Colin Bendell 的  [Should I Push?](https://shouldipush.com/)。\n\n底线：正如 Sam Saccone [所说](https://medium.com/@samccone/performance-futures-bundling-281543d9a0d5)，`preload` 有利于将资源的开始下载时间更接近初始请求， 而服务器推送是一个完整的 RTT（或 [更多](https://blog.yoav.ws/being_pushy/)，这取决于您的服务器反应时间 —— 如果你有一个服务器可以防止不必要的推送。\n\n<iframe data-src=\"https://www.youtube.com/embed/Cjo9iq8k-bc\" width=\"600\" height=\"480\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\n你使用 [流响应](https://jakearchibald.com/2016/streams-ftw/) 吗？通过流，在初始导航请求中呈现的 HTML 可以充分利用浏览器的流式 HTML 解析器。\n\n29. **你使用流响应吗?**\n\n[streams](https://streams.spec.whatwg.org/) 经常被遗忘和忽略，它提供了异步读取或写入数据块的接口，在任何给定的时间内，只有一部分数据可能在内存中可用。 基本上，只要第一个数据块可用，它们就允许原始请求的页面开始处理响应，并使用针对流进行优化的解析器逐步显示内容。\n\n我们可以从多个来源创建一个流。例如，您可以让服务器构建一个壳子来自于缓存，内容来自网络的流，而不是提供一个空的 UI 外壳并让它填充它。 正如 Jeff Posnick [指出](https://developers.google.com/web/updates/2016/06/sw-readablestreams)的，如果您的 web 应用程序由 CMS 提供支持的，那么服务器渲染 HTML 是通过将部分模板拼接在一起来呈现的，该模型将直接转换为使用流式响应，而模板逻辑将从服务器复制而不是你的服务器。Jake Archibald 的 [The Year of Web Streams](https://jakearchibald.com/2016/streams-ftw/) 文章重点介绍了如何构建它。对于性能的提升是非常明显的。\n\n流式传输整个 HTML 响应的一个重要优点是，在初始导航请求期间呈现的 HTML 可以充分利用浏览器的流式 HTML 解析器。 在页面加载之后插入到文档中的 HTML 块（与通过 JavaScript 填充的内容一样常见）无法利用此优化。\n\n浏览器支持程度如何呢? [详情请看这里](https://caniuse.com/#search=streams) Chrome 52+、Firefox 57、Safari 和 Edge 支持此 API 并且服务器已经支持所有的 [现代浏览器](https://caniuse.com/#search=serviceworker).\n\n30. **你使用 `Save-Data` 存储数据吗**?\n\n特别是在新兴市场工作时，你可能需要考虑优化用户选择节省数据的体验。 [Save-Data 客户端提示请求头](https://developers.google.com/web/updates/2016/02/save-data) 允许我们为成本和性能受限的用户定制应用程序和有效载荷。 实际上，您可以将 [高 DPI 图像的请求重写为低 DPI 图像](https://css-tricks.com/help-users-save-data/)，删除网页字体和花哨的特效，关闭视频自动播放，服务器推送，甚至更改提供标记的方式。\n\n该头部目前仅支持 Chromium，Android 版 Chrome 或 桌面设备上的 Data Saver 扩展。最后，你还可以使用 service worker 和 Network Information API 来提供基于网络类型的低/高分辨率的图像。\n\n31. **你是否激活了连接以加快传输？**\n\n使用 [资源提示](https://w3c.github.io/resource-hints) 来节约时间，如 [`dns-prefetch`](http://caniuse.com/#search=dns-prefetch) （在后台执行 DNS 查询），[`preconnect`](http://www.caniuse.com/#search=preconnect) （告诉浏览器在后台进行连接握手（DNS, TCP, TLS）），[`prefetch`](http://caniuse.com/#search=prefetch) (告诉浏览器请求一个资源) 和 [`preload`](https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/) (预先获取资源而不执行他们)。\n\n最近，我们至少会使用 `preconnect` 和 `dns-prefetch`，我们会小心使用 `prefetch` 和 `preload`；前者只能在你非常确定用户后续需要什么资源的情况下使用（类似于采购渠道）。注意，`prerender` 已被弃用，不再被支持。\n\n请注意，即使使用 `preconnect` 和 `dns-prefetch`，浏览器也会对它将并行查找或连接的主机数量进行限制，因此最好是将它们根据优先级进行排序（**感谢 Philip！**）。\n\n事实上，使用资源提示可能是最简单的提高性能的方法，[它确实很有效](https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf)。什么时候该使用呢？Addy Osmani [已经做了解释](https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf)，我们应该预加载确定将在当前页面中使用的资源。预获取可能用于未来页面的资源，例如用户尚未访问的页面所需的 Webpack 包。\n\nAddy 的关于 Chrome 中加载优先级的文章[展示了](https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf) Chrome 是如何精确地解析资源提示的，因此一旦你决定哪些资源对页面渲染比较重要，你就可以给它们赋予比较高的优先级。你可以在 Chrome DevTools 网络请求表格（或者 Safari Technology Preview）中启动“priority”列来查看你的请求的优先级。\n\n![the priority column in DevTools](https://user-gold-cdn.xitu.io/2018/2/28/161db9ebed0d24b3?w=400&h=136&f=gif&s=645590)\n\nDevTools 中的 \"Priority\" 列。图片来源于：Ben Schwarz，[重要的请求](https://css-tricks.com/the-critical-request/)\n\n例如，由于字体通常是页面上的重要资源，所以最好使用 [`preload`](https://css-tricks.com/the-critical-request/#article-header-id-2) [请求浏览器下载字体](https://css-tricks.com/the-critical-request/#article-header-id-2)。你也可以 [动态加载 JavaScript ](https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/#dynamic-loading-without-execution)，从而有效的执行延迟加载。同样的，因为 `<link rel=\"preload\">` 接收一个 `media` 的属性，你可以基于 `@media` 查询规则来有选择性地优先加载资源。\n\n[需要注意的一些问题是](https://dexecure.com/blog/http2-push-vs-http-preload/)：`preload` 可以 [将资源的下载时间移到请求开始时](https://www.youtube.com/watch?v=RWLzUnESylc)，但是这些缓存在内存中的预先加载的资源是绑定在所发送请求的页面上，也就是说预先加载的请求不能被页面所共享。而且，`preload` 与 HTTP 缓存配合得也很好：如果缓存命中则不会发送网络请求。\n\n因此，它对后发现的资源也非常有用，如：通过 background-image 加载的一幅 hero image，内联关键 CSS （或 JavaScript），并预先加载其他 CSS （或 JavaScript）。此外，只有当浏览器从服务器接收 HTML，并且前面的解析器找到了 `preload` 标签后，`preload` 标签才可以启动预加载。由于我们不等待浏览器解析 HTML 以启动请求，所以通过 HTTP 头进行预加载要快一些。[早期提示](https://tools.ietf.org/html/draft-ietf-httpbis-early-hints-05)将有助于进一步，在发送 HTML 响应标头之前启动预加载。\n\n请注意：如果你正在使用 `preload`，`as` **必须**定义否则[什么都不会加载](https://twitter.com/yoavweiss/status/873077451143774209)，还有，[预加载字体时如果没有 `crossorigin` 属性将会获取两次](https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf)\n\n32. **你优化渲染性能了吗？**\n\n使用 [CSS containment](http://caniuse.com/#search=contain) 隔离昂贵的组件 - 例如，限制浏览器样式、用于非画布导航的布局和绘画工作，第三方组件的范围。确保在滚动页面没有延迟，或者当一个元素进行动画时，持续地达到每秒 60 帧。如果这是不可能的，那么至少要使每秒帧数持续保持在 60 到 15 的范围。使用 CSS 的 [`will-change`](http://caniuse.com/#feat=will-change) 通知浏览器哪个元素的哪个属性将要发生变化。\n\n此外，评估[运行时渲染性能](https://aerotwist.com/blog/my-performance-audit-workflow/#runtime-performance)（例如，[使用 DevTools](https://developers.google.com/web/tools/chrome-devtools/rendering-tools/)）。可以通过学习 Paul Lewis 免费的[关于浏览器渲染优化的 Udacity 课程](https://www.udacity.com/course/browser-rendering-optimization--ud860)和 Emily Hayman 的文章[优化网页动画和交互](https://blog.algolia.com/performant-web-animations/)来入门。\n\n同样，我们有 Sergey Chikuyonok 这篇文章关于如何[正确使用 GPU 动画](https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/)。注意：对 GPU-composited 层的更改是[代价最小的](https://blog.algolia.com/performant-web-animations/)，如果你能通过“不透明”和“变形”来触发合成，那么你就是在正确的道路上。\n\n33. **你优化过渲染体验吗？**\n\n组件以何种顺序显示在页面上以及我们如何给浏览器提供资源固然重要，但是我们同样也不能低估了[感知性能](https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/)的角色。这一概念涉及到等待的心理学，主要是让用户在其他事情发生时保持忙碌。这就涉及到了[感知管理](https://www.smashingmagazine.com/2015/11/why-performance-matters-part-2-perception-management/)，[优先开始](https://www.smashingmagazine.com/2015/11/why-performance-matters-part-2-perception-management/#preemptive-start)，[提前完成](https://www.smashingmagazine.com/2015/11/why-performance-matters-part-2-perception-management/#early-completion)和[宽容管理](https://www.smashingmagazine.com/2015/12/performance-matters-part-3-tolerance-management/)。\n\n这一切意味着什么？在加载资源时，我们可以尝试始终领先于客户一步，所以将很多处理放置到后台，响应会很迅速。让客户参与进来，我们可以用[骨架屏幕](https://twitter.com/lukew/status/665288063195594752)（[实例演示](https://twitter.com/razvancaliman/status/734088764960690176)），而不是当没有更多优化可做时、用加载指示，添加一些动画/过渡[欺骗用户体验](https://blog.stephaniewalter.fr/en/cheating-ux-perceived-performance-and-user-experience/)。\n\n### HTTP/2\n\n34. **迁移到 HTTPS，然后打开 HTTP/2.**\n\n在谷歌提出[向更安全的网页进军](https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html)以及Chrome 会把（所有使用 HTTP 的）网页认定为“不安全”的大环境下，迁移到[HTTP/2](https://http2.github.io/faq/)是不可避免的。HTTP/2 从目前来看支持得非常好，并且，在某些场景下，使用 HTTP/2 会让你大力出奇迹。一旦运行在 HTTPS 上，你至少能够在 service workers 和 server push 方面获得[显著的性能提升](https://www.youtube.com/watch?v=RWLzUnESylc&t=1s&list=PLNYkxOF6rcIBTs2KPy1E6tIYaWoFcG3uj&index=25)。\n\n![HTTP/2](https://user-gold-cdn.xitu.io/2018/2/28/161db9ebffdfc09e?w=400&h=194&f=png&s=4896)\n\n最终，谷歌计划将所有 HTTP 页面标记为不安全的，并将有问题的 HTTPS 的 HTTP 安全指示器更改为红色三角形。（[图片来源](https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html)）\n\n最耗时的任务将是[迁移到 HTTPS](https://https.cio.gov/faq/)，取决于你的 HTTP/1.1 用户基础有多大（即使用旧版操作系统或浏览器的用户），你将不得不为旧版的浏览器性能优化发送不同的构建版本，这需要你采用[不同的构建流程](https://rmurphey.com/blog/2015/11/25/building-for-http2)。注意：开始迁移和新的构建过程可能会很棘手，而且耗费时间。接下来所讲的内容，都是针对之前切过 HTTP/2 环境或者现在正准备切 HTTP/2 环境（的读者）来展开的。\n\n35. **正确地部署 HTTP/2.**\n\n再次强调一下，需要对现阶段正如何提供在你开始使用 HTTP/2 请求资源之前，需要搞清楚你以前是如何请求资源的。另外需要你在载入大模块以及并行载入小模块之间找到一个平衡点。 。最终，仍然是[最好的请求就是没有请求](http://alistapart.com/article/the-best-request-is-no-request-revisited)，然而我们的目标是在快速传输资源和缓存之间找到一个好的平衡点。\n\n一方面，你可能想要避免合并所有资源，而是把整个界面分解成许多小模块，然后在构建过程中压缩这些小模块，最后通过[ “scount” approach 的方法](https://rmurphey.com/blog/2015/11/25/building-for-http2)引用和并行加载这些小模块。这样的话，一个文件的更改就不需要重新下载整个样式表或 JavaScript。这样还可以 [最小化解析时间](https://css-s.com/musings-on-http2-and-bundling/) ，并将单个页面的负荷保持在较低的水平。\n\n另一方面，[打包仍然很重要](http://engineering.khanacademy.org/posts/js-packaging-http2.htm)。首先，**压缩将获益**。在压缩大文件的过程中，借助目录重用的特点，达到优化性能的目的，而小的单独的文件则不会。有标准的工作来解决这个问题，但现在还远远不够。其次，浏览器还**没有为这种工作流优化**。例如，Chrome 将触发[进程间通信](https://www.chromium.org/developers/design-documents/inter-process-communication)（IPCs），与资源的数量成线性关系，因此页面中如果包含数以百计的资源将会造成浏览器性能损失。\n\n![Progressive CSS loading](https://user-gold-cdn.xitu.io/2018/2/28/161db9ebe6234eb0?w=400&h=291&f=png&s=15674)\n\n为了获得使用 HTTP/2 最好的效果，可以考虑使用[渐进地加载 CSS](https://jakearchibald.com/2016/link-in-body/)，正如 Chrome 的 Jake Archibald 所推荐的。\n\n你可以尝试[渐进地加载 CSS](https://jakearchibald.com/2016/link-in-body/)。显然，通过这样做，这种做法不利于 HTTP/1.1 的用户，因此在部署 HTTP/2 的过程中，你可能需要针对不同的浏览器创建并发送该浏览器支持的 HTTP 协议的报头，这还只是部署过程中稍微复杂的地方。你可以使用 [HTTP/2 的 connection coalescing](https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/)，可以让你在 HTTP/2 环境使用域名共享）来避开这些，但在实践中实现这一目标是很困难的。\n\n怎么做呢？如果你运行在 HTTP/2 之上，发送 **6-10 个包**是个理想的折中（对旧版浏览器也不会太差）。对于你自己的网站，你可以通过实验和测量来找到最佳的折中。\n\n36. **你的服务和 CDNs 支持 HTTP/2 吗？**\n\n不同的服务和 CDNs 可能对 HTTP/2 的支持情况不一样，但是可以使用[TLS ](https://istlsfastyet.com)来查看你的可选服务，或者快速的查看你的服务的性能以及你想要其支持的特性。\nTLS工具功能如下：\n\n![Is TLS Fast Yet?](https://user-gold-cdn.xitu.io/2018/2/28/161db9ebe6383ad3?w=400&h=255&f=png&s=11926)\n\n[Is TLS Fast Yet?](https://istlsfastyet.com) 允许你检查你转换到 HTTP\n/2 时你的服务器和 CDN 的选项。\n\n37. **是否启动了 OCSP stapling？**\n\n通过[在你的服务上启动 OCSP stapling](https://www.digicert.com/enabling-ocsp-stapling.htm)，你可以加速 TLS 握手。在线证书状态协议（OCSP）的提出是为了替代证书注销列表（CRL）协议。两个协议都是用于检查一个 SSL 证书是否已被撤回。但是，OCSP 协议不需要浏览器花时间下载然后在列表中搜索认证信息，因此减少了握手时间。\n\n38. **你是否已采用了 IPv6？**\n\n因为[ IPv4 即将用完](https://en.wikipedia.org/wiki/IPv4_address_exhaustion)以及主要的移动网络正在迅速采用 IPv6（美国已经[达到](https://www.google.com/intl/en/ipv6/statistics.html#tab=ipv6-adoption&tab=ipv6-adoption)50% 的 IPv6 使用阈值），[将你的 DNS 更新到 IPv6](https://www.paessler.com/blog/2016/04/08/monitoring-news/ask-the-expert-current-status-on-ipv6) 以应对未来是一个好的想法。只要确保在网络上提供双栈支持，就可以让 IPv6 和 IPv4 同时运行。毕竟，IPv6 不是向后兼容的。[研究显示](https://www.cloudflare.com/ipv6/)，也是正因为 IPv6 自带 NDP 以及路由优化，所以才能够让网站的载入速度提升10%到15%。\n\n39. **你使用（针对 HTTP 响应头压缩的）HPACK 压缩算法了吗？**\n\n如果你使用 HTTP/2，请再次检查，确保您的服务针对 HTTP 响应头部[实现 HPACK 压缩](https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2/)以减少不必要的开销。由于 HTTP/2 服务相对较新，它们可能不完全支持该规范，HPACK 就是一个例子。可以使用 [H2spec](https://github.com/summerwind/h2spec) 这个伟大的（如果技术上很详细）工具来检查。[HPACK作品](https://www.keycdn.com/blog/http2-hpack-compression/)。\n\n![h2spec](https://user-gold-cdn.xitu.io/2018/2/28/161db9ec7f519ed6?w=400&h=468&f=png&s=38725)\n\nH2spec ([View large version](https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/15891f86-c883-434a-8517-209273356ee6/h2spec-example-large-opt.png)) ([Image source](https://github.com/summerwind/h2spec))\n\nH2spec ([超大图](https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/15891f86-c883-434a-8517-209273356ee6/h2spec-example-large-opt.png)) ([图片来源](https://github.com/summerwind/h2spec))\n\n40. **务必保证服务器的安全性**\n\n所有实现了 HTTP/2 的浏览器都在 TLS 上运行的大背景下，如果你遇到以下问题：\n- 浏览器中出现安全警告\n- 页面上的某些元素不起作用。\n\n那么，你需要\n- [仔细检查那些与安全相关的 HTTP 头部，看是否设置正确](https://securityheaders.io/)\n- [使用一些工具来排除已知漏洞](https://www.smashingmagazine.com/2016/01/eliminating-known-security-vulnerabilities-with-snyk/)，\n- [检查你的证书看是否失效](https://www.ssllabs.com/ssltest/)\n- 确保所有外部插件和跟踪脚本通过 HTTPS 加载，不允许跨站点脚本\n- 正确设置 HTTP 中的 [strict-transport-security](https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet)和[ content-security-policy](https://content-security-policy.com/)请求头。\n\n41. **是否使用了 service workers 来缓存以及用作网络回退？**\n\n没有什么网络性能优化能快过用户机器上的本地缓存。如果你的网站运行在 HTTPS 上，那么请参考使用 “[Service Workers 的实用指南](https://github.com/lyzadanger/pragmatist-service-worker)”。使用 service worker 中缓存静态资源并存储离线资源（甚至离线页面）的目的，而且还会教你如何从用户的设备里面拿数据，也就是说，你现在是不需要通过网络的方式去请求之前的数据。同时，参考\nJake 的 [Offline Cookbook](https://jakearchibald.com/2014/offline-cookbook/) 和 Udacity 免费课程“[离线 Web 应用程序](https://www.udacity.com/course/offline-web-applications--ud899)”。浏览器支持？如上所述，它得到了[广泛支持](http://caniuse.com/#search=serviceworker) （Chrome、Firefox、Safari TP、Samsung Internet、Edge 17+），但不管怎么说，它都是网络。它有助于提高性能吗？[是的，Service Workers确实会提升性能](https://developers.google.com/web/showcase/2016/service-worker-perf)。\n\n### 测试和监控\n\n42. **你是了解否在代理浏览器和旧版浏览器中测试过？**\n\n在 Chrome 和 Firefox 中进行测试是不够的。你应该去了解你的网站在代理浏览器和旧版浏览器中是如何工作的。例如，UC 浏览器和 Opera Mini，这些浏览器 [在亚洲有大量的市场份额](http://gs.statcounter.com/#mobile_browser-as-monthly-201511-201611) （达到 35%）。在你感兴趣的国家[测量平均网络速度](https://www.webworldwide.io/)从而避免在未来发现“大惊喜”。测试网络节流，并仿真一个高 DPI 设备。[BrowserStack](https://www.browserstack.com) 很不错，但也要在实际设备上测试。\n\n[![](https://user-gold-cdn.xitu.io/2018/2/28/161db9eca1eb411c?w=725&h=572&f=gif&s=817417)](https://github.com/loadimpact/k6)\n\n[k6](https://github.com/loadimpact/k6) 可以让你像写单元测试一样编写性能测试用例。\n\n43. **是否启用了持续监控？**\n\n有一个[WebPagetest](http://www.webpagetest.org/)私人的实例总是有利于快速和无限的测试。但是，一个带有自动警报的连续监视工具将会给您提供更详细的性能描述。设置您自己的用户计时标记来度量和监视特定的业务度量。同时，考虑添加[自动化性能回归警报](https://calendar.perfplanet.com/2017/automating-web-performance-regression-alerts/)来监控随着时间而发生的变化。\n\n使用 RUM 解决方案来监视性能随时间的变化。对于自动化的类单元测试的负载测试工具，您可以使用 [k6](https://github.com/loadimpact/k6) 脚本 API。此外，可以了解下 [SpeedTracker](https://speedtracker.org)、[Lighthouse](https://github.com/GoogleChrome/lighthouse) 和 [Calibre](https://calibreapp.com)。\n\n### 速效方案\n\n这个列表非常全面，完成所有的优化可能需要很长时间。所以，如果你只有一个小时的时间来进行重大的改进，你会怎么做？让我们把这一切归结为**10个低挂的水果**。显然，在你开始之前和完成之后，测量结果，包括开始渲染时间以及在 3G 和电缆连接下的速度指数。\n\n1. 测量实际环境的体验并设定适当的目标。一个好的目标是：第一次有意义的绘制 < 1 s，速度指数 < 1250，在慢速的 3G 网络上的交互 < 5s，对于重复访问，TTI < 2s。优化渲染开始时间和交互时间。\n\n2. 为您的主模板准备关键的 CSS，并将其包含在页面的 `<head>` 中。（你的预算是 14 KB）。对于 CSS/JS，文件大小[不超过 170 KB gzipped](https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/)（解压后 0.8-1 MB）。\n\n3. 延迟加载尽可能多的脚本，包括您自己的和第三方的脚本——特别是社交媒体按钮、视频播放器和耗时的 JavaScript 脚本。\n\n4. 添加资源提示，使用 `dns-lookup`、`preconnect`、`prefetch` 和 `preload` 加速传输。\n\n5. 分离 web 字体，并以异步方式加载它们（或切换到系统字体）。\n\n6. 优化图像，并在重要页面（例如登录页面）中考虑使用 WebP。\n\n7. 检查 HTTP 缓存头和安全头是否设置正确。\n\n8. 在服务器上启用 Brotli 或 Zopfli 压缩。（如果做不到，不要忘记启用 Gzip 压缩。）\n\n9. 如果 HTTP/2 可用，启用 HPACK 压缩并开启混合内容警告监控。如果您正在运行 LTS，也可以启用 OCSP stapling。\n\n10. 在 service worker 缓存中尽可能多的缓存资产，如字体、样式、JavaScript 和图像。\n\n### 清单下载（PDF, Apple Pages）\n\n记住了这个清单，您就已经为任何类型的前端性能项目做好了准备。请随意下载该清单的打印版PDF，以及一个**可编辑的苹果页面文档**，以定制您需要的清单：\n\n* [Download the checklist PDF](https://www.dropbox.com/s/8h9lo8ee65oo9y1/front-end-performance-checklist-2018.pdf?dl=0) (PDF, 0.129 MB)\n* [Download the checklist in Apple Pages](https://www.dropbox.com/s/yjedzbyj32gzd9g/performance-checklist-1.1.pages?dl=0) (.pages, 0.236 MB)\n\n如果你需要其他选择，你也可以参考 [Rublic 的前端清单](https://github.com/drublic/checklist)和 Jon Yablonski 的“[设计师的 Web 性能清单](http://jonyablonski.com/designers-wpo-checklist/)”。\n\n### 动身吧\n\n一些优化可能超出了您的工作或预算范围，或者由于需要处理遗留代码而显得过度滥用。没问题！使用这个清单作为一个通用（并且希望是全面的）指南，并创建适用于你的环境的你自己的问题清单。但最重要的是，测试和权衡您自己的项目，以在优化前确定问题。祝大家 2018 年的性能大涨！\n\n**非常感谢 Guy Podjarny, Yoav Weiss, Addy Osmani, Artem Denysov, Denys Mishunov, Ilya Pukhalski, Jeremy Wagner, Colin Bendell, Mark Zeman, Patrick Meenan, Leonardo Losoviz, Andy Davies, Rachel Andrew, Anselm Hannemann, Patrick Hamann, Andy Davies, Tim Kadlec, Rey Bango, Matthias Ott, Mariana Peralta, Philipp Tellis, Ryan Townsend, Mohamed Hussain S H, Jacob Groß, Tim Swalling, Bob Visser, Kev Adamson, Aleksey Kulikov and Rodney Rehm 对这篇文章的校对，同样也感谢我们出色的社区，分享了他们在性能优化工作中学习到的技术和经验，供大家使用。你们真正的非常了不起！**\n\n\n\n",
            "desc": "![](https://user-gold-cdn.xitu.io/2018/2/28/161dba201c0a6499?imageView2/1/w/1304/h/734/q/85/format/webp/interlace/1) 前言：这篇文章我在掘金翻译计划中跟着一起翻译的文章（感谢掘金翻译），我翻译了第三部分，然后校对了第二部分，这篇文章对于前端性能优化的技术还是比较新颖和全面的，所以决定自己阅读一遍英文原文，然后又用思维导图整理了下重点，英文原文还是挺长的，所以  如果想要粗略的了解本文内容的可以直接查看我总结的思维导图 如果看完思维导图觉得本文对你有所帮助的，可以查看我自己翻译并根据其他人翻译整理后的文章 如果你英文阅读没有障碍，并且觉得我翻译不好的，可以直接阅读 英文原文  推荐大家时间充裕的话可以自己阅读英文原文，此文是根据掘金翻译的四篇文章 +  其他的翻译文章 + 自己翻译修改得出的。因为翻译大家懂得，会有一些错误的地方，欢迎大家指出，本人不保证翻译没有错误，但已经尽力去翻译了，所以欢迎大家直接阅读英文原文！！欢迎大家直接阅读英文原文！！欢迎大家直接阅读英文原文！！  作者：sunshine小小倩 链接：https://juejin.im/post/5a966bd16fb9a0635172a50a 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
            "title": "2018 前端性能优化清单",
            "tag": "FE",
            "author": "cherry",
            "__v": 0
        },
        {
            "toc": [],
            "state": "draft",
            "readingQuantity": 0,
            "createAt": "2019-04-15T15:44:29.849Z",
            "updateAt": "2019-04-14T14:22:39.347Z",
            "_id": "5cb4a6dd15b14b29fb28e02b",
            "id": null,
            "content": "# Alfred\n## 获取\n  - 官网安装，简单方便，免费版虽然功能阉割，但是够用\n  - 也可以购买 Powerpack，购买之后可以使用 Alfred 的所有功能，主要是 Workflows 自定义插件的工作流。也可以在网上找破解版的。\n\n## Alfred 设置\n![Alfred 设置](https://user-gold-cdn.xitu.io/2018/5/30/163b10711e38ac94?w=526&h=378&f=jpeg&s=49836)\n\n\nAlfred 设置主要有以下几个部分：\n- General：通用\n- Features：特性\n- Workflows：工作流\n- Appearance：主题\n- Powerpack：付费\n![Alfred设置](https://user-gold-cdn.xitu.io/2018/5/30/163b10711b8183da?w=2202&h=1428&f=jpeg&s=487193)\n### General（通用界面）\n![General](https://user-gold-cdn.xitu.io/2018/5/30/163b10711e1e062f?w=2200&h=1436&f=jpeg&s=514840)\n### Features（特性界面）\n- Essentials：可设置搜索“应用程序(默认自动选中)”、“联系人”、“设置”。\n- Extras：可设置搜索“文件夹”、“文本文件”、“压缩”、“文档”、“图片”、“AppleScript”等其他文件。\n- Unintelligent：`Search all file types` 搜索所有文件类型。我们可以使用 `Find+空格+文件名` 来查询文件或文件夹；使用 `Open+空格+文件名` 也可以打开文件。\n- Search Scope：设置 Alfred 查询时会搜索的文件夹范围，可自己添加和删除。\n- Fallbacks：若上面的查询搜索不到结果时，就会调用这里设置的网站或搜索引擎来进行进一步的查询。默认反馈结果为 Google、Amazon、Wikipedia 网页搜索。\n\n- 比如，你可以输入 `app+空格+应用名` 打开应用\n![image](https://user-gold-cdn.xitu.io/2018/5/30/163b1074b56001d6?w=1152&h=710&f=jpeg&s=127798)\n- 你也可以输入 `find+空格+文件名` 搜索文件\n![image](https://user-gold-cdn.xitu.io/2018/5/30/163b10711e6dda51?w=1154&h=994&f=jpeg&s=175643)\n- 输入 `open+空格+文件名` 打开文件\n\n## Web Search\n我们可以这样使用 Web Search\n![image](https://user-gold-cdn.xitu.io/2018/5/30/163b10711e3841a1?w=640&h=480&f=gif&s=11697726)\n个人认为 Alfred 最赞的功能就是 Web Search 的搜索了\n\n可以根据设置的关键字和 url 进行网页的搜索。可以极大的提高开发效率\n\n比如我可以再 Alfred 的搜索页面输入 `google js` 点击回车我就可以直接打开我的 Chrome 浏览器并且到了 Google 搜索结果是 `js` 的页面。\n\n还可以自定义搜索页面\n\n![image](https://user-gold-cdn.xitu.io/2018/5/30/163b107128edf5a7?w=700&h=431&f=jpeg&s=43258)\n比如你可以设置：\n- 百度：`https://www.baidu.com/s?ie=utf-8&f=8&wd={query}`\n- stackoverflow：`http://www.stackoverflow.com/search?q={query}`\n- githubUser：`https://github.com/{query}`\n- githubSearch：`https://github.com/search?utf8=%E2%9C%93&q={query}`\n- MDN：`https://developer.mozilla.org/zh-CN/search?q={query}`\n![image](https://user-gold-cdn.xitu.io/2018/5/30/163b107171b6c6f4?w=1698&h=1230&f=jpeg&s=342550)\n\n## Calculator（计算器）\n- 直接在操作界面上输入简单的运算\n![image](https://user-gold-cdn.xitu.io/2018/5/30/163b1071781e6279?w=1146&h=250&f=jpeg&s=34137)\n- 在操作界面上输入=来进行复杂运算，Alfred支持很多高级的数学函数\n![image](hao'jiu)\n\n## Web Bookmarks（浏览器书签）\n可以设置搜索关键字搜索浏览器书签。例如\n![image](https://user-gold-cdn.xitu.io/2018/5/30/163b10718b295c8b?w=2200&h=1436&f=jpeg&s=310602)\n![image](https://user-gold-cdn.xitu.io/2018/5/30/163b10719f373c1b?w=1154&h=350&f=jpeg&s=83452)\n\n## Dictionary\n同 Bookmarks，可以谁知关键字然后使用macOS 自带的 Dictionary 搜索结果\n![image](https://user-gold-cdn.xitu.io/2018/5/30/163b1071bb4f264e?w=2200&h=1436&f=jpeg&s=329293)\n\n![image](https://user-gold-cdn.xitu.io/2018/6/1/163b97f526075686?w=1154&h=810&f=jpeg&s=160245)\n\n# CheatSheet\n长按 `command` 会显示当前页面的快捷键\n![image](https://user-gold-cdn.xitu.io/2018/5/30/163b1075837bf2c6?w=1003&h=414&f=png&s=189725)\n\n# spectacle\n官网：https://www.spectacleapp.com/\n\nspectacle 可以方便移动和 resize 窗口，这个的需求主要是在开发时都会有大于等于 2 个屏幕，我们的窗口在不同的屏幕之间来回切换的时候会比较繁琐\n\n# Bartender\nMac下菜单栏管理应用，可以让菜单栏上杂乱无章的图标，变得井井有条\n\n# Helium\n始终悬浮在窗口前面的浏览器\n\n# Dashlane\n官网：https://www.dashlane.com/zh\n\n安全记住所有密码\n\n# switchHost!\n方便管理你的 host\n\n# PicGIF\n方便的制作 gif 的及其轻量的小软件，本文的 gif 就是使用该软件制作\n",
            "desc": "![](https://user-gold-cdn.xitu.io/2018/5/30/163b10c06ebae5a0?imageView2/1/w/1080/h/320/q/85/format/webp/interlace/1) 好久没有更新文章了，分享一些最近使用的一些提升开发效率的小工具，持续更新哦，如果大家有什么推荐的提升开发效率的小工具欢迎留言哦~",
            "title": "Mac 提升开发效率的小工具",
            "tag": "FE",
            "author": "cherry",
            "__v": 0
        },
        {
            "toc": [],
            "state": "publish",
            "readingQuantity": 0,
            "createAt": "2019-04-15T15:42:50.756Z",
            "updateAt": "2019-04-14T14:22:39.347Z",
            "_id": "5cb4a67a15b14b29fb28e02a",
            "id": null,
            "content": "# 什么是 webpack，为什么要使用 webpack\n## 什么是 webpack\n官网给出的概念是：\n> 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。\n根据官网最直观最出名的那个图我们可以知道，webpack 可以**打包/脚本/图片/样式/表**\n从图中我们可以看出左边有依赖关系的模块（MODULES WITH DEPENDENCIES）通过 webpack 打包成了各种静态资源（STATIC ASSETS）\n## 为什么要使用 webpack\n通过上面的概念，你是不是已经大概知道了 webpack 是干什么的，那么问题来了，为什么要使用 webpack 呢？\n这就说来话长了，那就长话短说，emmmm\n\n为什么使用 webpack，这应该是和前端的发展有关系的，我认为，webpack 是前端发展到一定阶段的必然产物（貌似是一句废话）。\n因为计算机网络的飞速发展，导致 web 前端也在迅猛发展。最初的实践方案已经不能满足我们的需求，于是，越来越多的新技术新思想新框架孕育而生，比如：\n### 前端模块化\n随着前端项目的复杂度越来越高，相互之前的依赖越来越多，以及为了更好的复用代码，前端也需要用模块化的思想来组织代码。\n\n首先我们要明白模块化解决了前端的哪些痛点：\n- 命名冲突\n- 文件依赖（js 加载顺序）\n- 代码复用\n\n我们这里说的模块和 Java 的 `package` 的概念是类似的。逻辑上相关的代码放在一个包中，每一个包都是相互独立的，不用担心命名冲突的问题，如果其他人想要用这部分功能，直接 `import` 导入包就好\n\n所以前端代码模块化的实现，会帮我们解决命名冲突和代码复用的问题，那么文件依赖要怎么处理呢？这就用到了我们的 webpack，稍后再做介绍。\n\n所以有了模块，我们就可以方便的复用他人的代码，那么问题来了，无规矩不成方圆，我们在使用他人代码的时候肯定是要遵循某种规范，所以就出现了 CommonJS、AMD 和 终极模块化方案 —— ES6 模块，这些都是前端模块化的规范。\n\n我们来简单了解一下：\n\n#### CommonJS\nnode.js 采用的就是 CommonJS 规范，使用 `require` 的方法**同步**加载依赖，一个文件就是一个模块，导入导出格式如下：\n```\n// 导入\nconst moduleA = require('./moduleA');\n\n// 导出\nmodule.exports = moduleA.someFunc;\n```\n缺点是加载的模块是同步的，只有加载完才能执行后面的操作。因为 node.js 的模块文件一般存在于本地硬盘，所以一般不会出现这个问题，但是在浏览器环境该规范就不那么适用了。\n\n#### AMD\n原因如上，因为 CommonJS 不适用于浏览器环境，所以出现了 AMD 规范。该规范**异步**加载依赖，可以再声明的时候指定需要加载的依赖，并且需要当做参数传入，对于依赖的模块提前执行，依赖前置。\n\n写法如下：\n```\ndefine(\"module\", [\"dep1\", \"dep2\"], function(d1, d2) {\n  return someExportedValue;\n});\nrequire([\"module\", \"../file\"], function(module, file) { /* ... */ });\n```\n\n#### ES6 模块化\nES6 直接在语言层面上实现了模块化。我们现在用的最多的就是 ES6 模块化的实践方式。\n\n写法如下：\n```\n// 导入\nimport { readFile } from 'fs';\nimport React from 'react';\n// 导出\nexport function hello() {};\nexport default {\n  // ...\n};\n```\n\n#### 样式模块化\n现在越来越多人也开始使用模块化的思想写样式。比如现在大部分的 CSS 预编译器都支持 `@import` 的写法。将一些公用样式放在一个文件中，在其他文件中导入。\n\n-----------\n三大框架的出现，使我们不需要像传统的 JQ 一样操作 DOM，将精力集中在对数据的处理上。\n\n以及 ES6/7/8 和 TS 的使用越来普及，无疑使我们的开发效率提高了很多。\n\n**但是出现的问题是：这些新兴的技术并不是在所有的浏览器上都适用，都需要将源代码转化为可以直接在浏览器上运行的代码**\n\n所以，webpack 就解决了这个问题。\n\n# Gulp/Grunt、Rollup 和 webpack 的比较\n## Gulp/Grunt\n其实，Gulp/Gunt 和 webpack 应该是没有可比性的，但是他们都可以称为前端自动化构建工具（让我们不再做机械重复的事情，解放我们的双手）\n\n但是 Gulp/Gunt 和 webpack 确实干的不是一件事\n\n**Gulp 本质是 task runner，Webpack 是 module bundler**\n\n我认为 Gulp 正如他的定义一样：**基于流的自动化构建工具**，定义每一个任务，然后自动将一个个任务执行。\n\n而 webpack 是模块化地组织，模块化地依赖，然后模块化地打包。相对来上，场景局限在前端模块化打包上。\n\n推荐知乎 寸志 大佬的回答：[gulp 有哪些功能是 webpack 不能替代的？](https://www.zhihu.com/question/45536395/answer/164361274)\n\n## Rollup\n> Rollup 是一个和 Webpack 很类似但专注于 ES6 的模块打包工具。 Rollup 的亮点在于能针对 ES6 源码进行 Tree Shaking 以去除那些已被定义但没被使用的代码，以及 Scope Hoisting 以减小输出文件大小提升运行性能。 然而 Rollup 的这些亮点随后就被 Webpack 模仿和实现。 由于 Rollup 的使用和 Webpack 差不多，这里就不详细介绍如何使用了，而是详细说明它们的差别：\n\nRollup 是在 Webpack 流行后出现的替代品；\nRollup 生态链还不完善，体验不如 Webpack；\nRollup 功能不如 Webpack 完善，但其配置和使用更加简单；\nRollup 不支持 Code Spliting，但好处是打包出来的代码中没有 Webpack 那段模块的加载、执行和缓存的代码。\nRollup 在用于打包 JavaScript 库时比 Webpack 更加有优势，因为其打包出来的代码更小更快。 但功能不够完善，很多场景都找不到现成的解决方案。\n\n# 安装与使用\n\n\n## 创建 `package.json` 文件\n可以手动的创建，也可以使用命令自动创建\n```\nnpm init\n```\n\n## 安装\nwebpack 可以直接使用 npm 安装，可以安装到全局，也可以安装到项目\n```\n//全局安装\nnpm install -g webpack\n//安装到你的项目目录\nnpm install --save-dev webpack\n```\n\n## 使用\n推荐大家阅读这篇文章：[\n入门 Webpack，看这篇就够了](https://segmentfault.com/a/1190000006178770)\n\n我就是跟着这篇文章做的\n\n### 新建文件\n首先新建一个文件夹，然后在终端打开该文件夹并执行来初始化你的项目，在初始过程中，会有一些问题帮助你创建 `package.json` 文件。\n```bash\nnpm init\n```\n\n初始化之后我们还要创建几个文件来存放我们的项目文件。\n\n创建一个 `app` 文件夹来存放我们打包之前的源文件\n\n创建一个 `public` 文件夹来存放一个入口文件 `index.html` 和通过 webpack 打包之后浏览器可直接运行的 `js` 文件\n\n比如我们在 `app` 文件夹下创建一个 `Greeter.js` 文件，里面有一个方法可以再页面显示文字信息  `Hi there and greetings!`\n\n```js\nmodule.exports = function() {\n  var greet = document.createElement('div');\n  greet.textContent = \"Hi there and greetings!\";\n  return greet;\n};\n```\n\n然后我们创建一个 `main.js` 来引入 `Greeter.js` 这个文件，\n\n浏览器的入口 `index.html` 文件内容如下(其中 `bundle.js` 是打包之后的文件)：\n```html\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Webpack Sample Project</title>\n  </head>\n  <body>\n    <div id='root'>\n    </div>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n```\n\n此时的文件路径如下\n```\n.\n├── app\n│   ├── Greeter.js\n│   └── main.js\n├── package.json\n├── public\n│   ├── bundle.js\n│   └── index.html\n```\n\n### 安装 webpack\n初始化项目之后，要安装 webpack\n```bash\nnpm install --save-dev webpack\n```\n在安装完 webpack 之后，可以再 `package.json` 文件中看到增加了 webpack 的依赖。\n\n### 配置 webpack\n安装完 webpack 之后，我们就要配置 webpack 了，首先创建配置文件 `webpack.config.js` 文件内容如下：\n\n```js\nmodule.exports = {\n  entry:  __dirname + \"/app/main.js\",//已多次提及的唯一入口文件\n  output: {\n    path: __dirname + \"/public\",//打包后的文件存放的地方\n    filename: \"bundle.js\"//打包后输出文件的文件名\n  }\n}\n```\n然后我们在该项目的终端输入 \n```bash\nwebpack\n```\n就可以看到如下信息：\n```\nHash: 4e6a6b5eb88a83b29e02\nVersion: webpack 4.12.0\nTime: 551ms\nBuilt at: 2018-06-24 14:53:39\n    Asset      Size  Chunks             Chunk Names\nbundle.js  6.82 KiB       0  [emitted]  main\n[3] ./node_modules/css-loader!./app/main.css 190 bytes {0} [built]\n[4] ./app/main.css 1.04 KiB {0} [built]\n[5] ./app/Greeter.js 143 bytes {0} [built]\n[6] ./app/main.js 119 bytes {0} [built]\n    + 3 hidden modules\n\nWARNING in configuration\nThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.\nYou can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/\n```\n\n看到这样的信息，那么恭喜你，你的第一个 webpack 项目就完成了！\n\n打开 `public` 文件夹下面的 `index.html`，你就可以再浏览器上看到如下的效果。\n\n# Loader\n> loader 用于对模块的源代码进行转换。loader 可以使你在 import 或\"加载\"模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！\n\n**因为 webpack 本身只能处理 JavaScript，如果要处理其他类型的文件，就需要使用 `loader` 进行转换，`loader` 本身就是一个函数，接受源文件为参数，返回转换的结果。**\n\n## 举个 🌰 —— `css-loader`\n例如，我们想在刚刚的页面增加样式，使文字居中显示，那么我在 `app` 文件夹下面新建一个 `main.css` 文件。在 webpack 中，所有的文件都是模块，所以要使用这个 `css` 文件，就必须要先引入。\n\n### 引入 `css` 文件\n所以我就在 `app` 文件夹下面的 `main.js` 中引入该 css 文件\n```js\nconst greeter = require('./Greeter.js');\nrequire ('./main.css')\ndocument.querySelector(\"#root\").appendChild(greeter());\n```\n\n### 重新打包\n然后我重新打包一遍，蓝后，发现居然报错了！\n```bash\nHash: 179c18498fac6de89a96\nVersion: webpack 4.12.0\nTime: 533ms\nBuilt at: 2018-06-24 15:00:24\n 1 asset\n[0] ./app/Greeter.js 143 bytes {0} [built]\n[1] ./app/main.js 119 bytes {0} [built]\n\nWARNING in configuration\nThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.\nYou can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/\n\nERROR in ./app/main.js\nModule not found: Error: Can't resolve 'style-loader' in '/Users/cherry/Workspace/webpack-demo'\n @ ./app/main.js 2:0-22\n```\n根据报错信息，我们很明显能发现是提示我们项目缺少 `style-loader`，这是因为 webpack 原生只支持解析 js 文件，要支持非 js 类型的文件，就需要使用 `loader`\n\n### 安装 loader \n所以我们要安装 `style-loader` 和 `css-loader`\n```bash\nnpm i -D style-loader css-loader\n```\n\n### 修改配置文件\n然后修改 webpack 的配置文件 `webpack.config.js`\n```js\nmodule.exports = {\n  entry:  __dirname + \"/app/main.js\",//已多次提及的唯一入口文件\n  output: {\n    path: __dirname + \"/public\",//打包后的文件存放的地方\n    filename: \"bundle.js\"//打包后输出文件的文件名\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      }\n    ]\n  }\n}\n```\n配置文件增加了 `module.rules` 数组，该数组是一些配置规则，告诉 webpack 符合 `test` 的文件需要使用 `use` 后面的 `loader` 处理。所以该规则就是对所有 `.css` 结尾的文件使用 `style-loader`、`css-loader` 进行处理。\n\n## loader 特性\n我们来看一下 `loader` 有哪些特性：\n- loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。\n- loader 可以是同步的，也可以是异步的。\n- loader 运行在 Node.js 中，并且能够执行任何可能的操作。\n- loader 接收查询参数。用于对 loader 传递配置。\n- loader 也能够使用 options 对象进行配置。\n- 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。\n- 插件(plugin)可以为 loader 带来更多特性。\n- loader 能够产生额外的任意文件。\n\n## 使用 webpack 的三种姿势\nwebpack 中使用 loader 有三种姿势\n### 通过 CLI\n命令行中运行 \n```bash\nwebpack --module-bind jade  --module-bind 'css=style!css'   \n``` \njade,style,css后面可省略-loader，他们分别对.jade使用jade-loader,对.css使用style-loader和css-loader\n\n### 通过require \n可以直接在源码中指定使用什么 loader 去处理文件。\n```bash\nrequire('style-loader!css-loader?minimize!./main.css')\n```\n这样就是对 `./main.css` 文件先使用 `css-loader` 再使用 `style-loader` 进行转换\n\n### 使用配置文件 `webpack.config.js`\n最常用的方式就是使用本文所使用的配置文件的方式\n\n## 常见的 loader\n[常见的 loader](http://www.css88.com/doc/webpack/loaders/)\n\nloader name | loader des\n---|---\n`babel-loader` | 加载 ES2015+ 代码，然后使用 Babel 转译为 ES5\n`buble-loader` | 使用 Bublé 加载 ES2015+ 代码，并且将代码转译为 ES5\n`cache-loader` | 在一些性能开销较大的 loader 之前添加此 loader，以将结果缓存到磁盘里。\n`coffee-loader` | 将 `CoffeeScript` 转化为 JS\n`css-loader` | `css-loader` 是将 `@import`、`url()` 引入的 css 转换为 `import/require()` 的方式然后在解析他们\n`exports-loader` | 通过添加 `exports[...] = ...` 语句导出文件中的变量。\n`expose-loader` | `expose-loader` 将模块添加到全局对象上\n`file-loader` | `file-loader` 可以解析项目中的url引入（不仅限于css），根据我们的配置，\n将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。\n`gzip-loader` | 可以加载 gzip 压缩之后的资源\n`html-loader` | 将 html 输出为字符串，也可以根据配置进行压缩\n`imports-loader` | `imports-loader` 允许使用依赖于特定全局变量的模块，这对于依赖于像 `$` 这样的全局变量的第三方模块非常有用\n`jshint-loader` | 为加载的模块使用 jshint\n`json-loader` | 由于 webpack >= v2.0.0 默认支持导入 JSON 文件。如果你使用自定义文件扩展名，你可能仍然需要使用此 loader\n`json5-loader` | 将 json5 文件解析成 js 对象\n`less-loader` | 将 less 转化为 css\n`null-loader` | 返回一个空模块\n`postcss-loader` | 将 postcss 转化为 css\n`raw-loader` | 加载文件原始内容(utf-8格式)\n`sass-loader` | 将 SASS/SCSS 转换为 css\n`source-map-loader` | 从现有源文件（源代码源URL）中提取源映射，方便调试\n`style-loader` | 将 CSS 放在 `<style>` 标签中注入到 DOM 中\n`script-loader` | 在全局上下文中执行一次 JavaScript 文件（如在 script 标签），不需要解析\n`svg-inline-loader` | 将 SVG 作为模块嵌入\n`url-loader` | 将文件加载为 Base64 编码的 URL\n\n\n\n\n\n\n\nrow 2 col 1 | row 2 col 2\n# Plugin\n> 插件(plugin)是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！\n插件目的在于解决 loader 无法实现的其他事\n\n> Plugin 是用来扩展 Webpack 功能的，通过在构建流程里注入钩子实现，它给 Webpack 带来了很大的灵活性。\n\n通过plugin（插件）webpack可以实 loader 所不能完成的复杂功能，使用 plugin 丰富的自定义 API 以及生命周期事件，可以控制 webpack 打包流程的每个环节，实现对 webpack 的自定义功能扩展。\n\n## 举个 🌰 —— ExtractTextPlugin\n**webpack4 已经不支持用extract-text-webpack-plugin来优化 css, 需要改成optimize-css-assets-webpack-plugin和mini-css-extract-plugin**\n\n在刚刚的例子中，我们查看打包之后的 `index.html` 文件可以看到我们刚刚写的 css 代码放在了 `head` 中的 `style` 标签中，这是 `style-loader` 帮我们处理的\n\n但是，如果你希望打包之后 css 在单独的文件中，那么你就需要 `ExtractTextPlugin` 这个 plugin 了。\n\n### 安装 `ExtractTextPlugin`\n```bash\nnpm i -D ExtractTextPlugin\n```\n\n### 修改配置文件 \n我们需要修改配置文件：\n```js\nconst path = require('path')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nmodule.exports = {\n  entry:  __dirname + \"/app/main.js\",//已多次提及的唯一入口文件\n  output: {\n    path: __dirname + \"/public\",//打包后的文件存放的地方\n    filename: \"bundle.js\",//打包后输出文件的文件名\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        // 转换 .css 需要的 loader\n        loaders: ExtractTextPlugin.extract({\n          use: ['css-loader'],\n        })\n      }\n    ]\n  },\n  plugins: [\n    new ExtractTextPlugin({\n      filename: '[name]-[contenthash:8].css'\n    })\n  ]\n}\n```\n然后我们再重新打包，就可以发现在 `public` 文件夹下面多了一个 `main-493a2c3c.css` 文件，下面我们要在 `index.html` 中自动引入这个 css 文件\n\n## `html-webpack-plugin`\n`html-webpack-plugin` 可以根据你设置的模板，在每次运行后生成对应的模板文件，同时所依赖的 CSS/JS 也都会被引入，如果 CSS/JS 中含有 hash 值，则 `html-webpack-plugin` 生成的模板文件也会引入正确版本的 CSS/JS 文件。\n\n### 安装 `html-webpack-plugin`\n安装方式我们已经很熟悉了\n```bash\nnpm i -D html-webpack-plugin\n```\n\n#### 修改配置文件\n```js\nconst path = require('path')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin');  \n\nmodule.exports = {\n  entry:  __dirname + \"/app/main.js\",//已多次提及的唯一入口文件\n  output: {\n    path: __dirname + \"/public\",//打包后的文件存放的地方\n    filename: \"bundle.js\",//打包后输出文件的文件名\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        loaders: ExtractTextPlugin.extract({\n          use: ['css-loader'],\n        })\n      }\n    ]\n  },\n  plugins: [\n    new ExtractTextPlugin({\n      filename: '[name]-[contenthash:8].css'\n    }),\n    new HtmlWebpackPlugin(),\n  ]\n}\n```\n\n蓝后我们删除之前我们在 `punlic` 文件夹下面 `index.html` 的内容，在打包一次，就会生成一个 `html` 模板\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>Webpack App</title>\n  <link href=\"main-493a2c3c.css\" rel=\"stylesheet\"></head>\n  <body>\n  <script type=\"text/javascript\" src=\"bundle.js\"></script></body>\n</html>\n```\n在 `new HtmlWebpackPlugin` 的时候，我们可以进行一系列的配置\n```js\n    new HtmlWebpackPlugin({  \n      // 生成的HTML模板的title，如果模板中有设置title的名字，则会忽略这里的设置\n      title: \"This is the webpack config\", \n      \n      // 生成的模板文件的名字\n      filename: \"/index.html\", \n      \n      // 模板来源文件 \n      template: \"index.html\", \n      \n      // 引入模块的注入位置；取值有true/false/body/head \n      // true 默认值，script标签位于html文件的 body 底部\n      // body script标签位于html文件的 body 底部\n      // head script标签位于html文件的 head中\n      // false 不插入生成的js文件，这个几乎不会用到的\n      inject: \"body\", \n      \n      // 指定页面图标； \n      favicon: \"\", \n      \n      // 是html-webpack-plugin中集成的 html-minifier ，生成模板文件压缩配置 \n      minify: {  \n          caseSensitive: false, //是否大小写敏感  \n          collapseBooleanAttributes: true, // 省略布尔属性的值  \n          collapseWhitespace: true //删除空格 \n      }, \n      \n      // 是否生成hash添加在引入文件地址的末尾，类似于我们常用的时间戳，避免缓存带来的麻烦\n      hash: true,\n      \n      // 是否需要缓存，如果填写true，则文件只有在改变时才会重新生成\n      cache: true,  \n      \n      // 是否将错误信息写在页面里，默认true，出现错误信息则会包裹在一个pre标签内添加到页面上\n      \n      showErrors: true,  \n      \n      // 引入的模块，这里指定的是entry中设置多个js时，在这里指定引入的js，如果不设置则默认全部引入\n      chunks: \"\",  \n      \n      // 引入模块的排序方式\n      // 默认四个选项： none auto dependency {function}\n      // 'dependency' 文件的依赖关系\n      // 'auto' 默认值，插件的内置的排序方式\n      // 'none' 无序\n      // {function} 自定义\n      chunksSortMode: \"auto\",  \n      \n      // 排除的模块\n      excludeChunks: \"\",  \n      \n      // 生成的模板文档中标签是否自动关闭，针对xhtml的语法，会要求标签都关闭，默认false\n      xhtml: false  \n    \n    }),\n```\n\n## 常见的 plugin\n摘自：http://www.css88.com/doc/webpack/plugins/\nName |\tDescription\n---|---\nAggressiveSplittingPlugin |\t将原来的 chunk 分成更小的 chunk\nBabiliWebpackPlugin |\t基于 Babel 的裁剪工具：Babili\nBannerPlugin\t| 在每个生成的 chunk 顶部添加 banner\nCommonsChunkPlugin |\t提取 chunks 之间共享的通用模块\nComponentWebpackPlugin |通过 webpack 使用组件\nCompressionWebpackPlugin\t|预先准备的资源压缩版本，使用 Content-Encoding 提供访问服务\nContextReplacementPlugin|\t重写 require 表达式的推断上下文\nDefinePlugin\t|允许在编译时(compile time)配置的全局常量\nDllPlugin\t|为了极大减少构建时间，进行分离打包\nEnvironmentPlugin\t|DefinePlugin 中 process.env 键的简写方式。\nExtractTextWebpackPlugin\t|从 bundle 中提取文本（CSS）到单独的文件\nHotModuleReplacementPlugin\t|启用模块热替换(Enable Hot Module Replacement - HMR)\nHtmlWebpackPlugin\t|简单创建 HTML 文件，用于服务器访问\nI18nWebpackPlugin\t|为 bundle 增加国际化支持\nIgnorePlugin\t|从 bundle 中排除某些模块\nLimitChunkCountPlugin\t|设置 chunk 的最小/最大限制，以微调和控制 chunk\nLoaderOptionsPlugin\t|用于从 webpack 1 迁移到 webpack 2\nMinChunkSizePlugin\t|确保 chunk 大小超过指定限制\nNoEmitOnErrorsPlugin\t|在输出阶段时，遇到编译错误跳过\nNormalModuleReplacementPlugin\t|替换与正则表达式匹配的资源\nNpmInstallWebpackPlugin\t|在开发时自动安装缺少的依赖\nProvidePlugin\t|不必通过 import/require 使用模块\nSourceMapDevToolPlugin\t|对 source map 进行更细粒度的控制\nUglifyjsWebpackPlugin\t|可以控制项目中 UglifyJS 的版本\nZopfliWebpackPlugin\t|通过 node-zopfli 将资源预先压缩的版本\n\n\n参考文章：\n- [深入浅出 webpack](http://webpack.wuhaolin.cn/)\n- [入门 webpack，看这篇就够了](https://segmentfault.com/a/1190000006178770)\n- [webpack配置常用loader加载器](https://www.cnblogs.com/hughes5135/p/6891784.html?utm_source=itdadao&utm_medium=referral)\n- [webpack 中文文档](http://www.css88.com/doc/webpack/)",
            "desc": "![](https://user-gold-cdn.xitu.io/2018/6/24/1643283f9728917e?imageView2/1/w/1080/h/320/q/85/format/webp/interlace/1)",
            "title": "webpack 从入门到放弃(一)",
            "tag": "FE",
            "author": "cherry",
            "__v": 0
        },
        {
            "toc": [],
            "state": "draft",
            "readingQuantity": 0,
            "createAt": "2019-04-15T15:41:20.691Z",
            "updateAt": "2019-04-14T14:22:39.347Z",
            "_id": "5cb4a62015b14b29fb28e029",
            "id": null,
            "content": "> 项目地址： https://github.com/sunshine940326/changelog-test\n# `commit message` 的作用\n- 提供更多的历史信息，方便快速浏览。\n- 可以过滤某些commit（比如文档改动），便于快速查找信息。\n- 可以直接从commit生成Change log。\n\n# `commit message` 的格式\n刚刚有说到，我们使用的是 [Angular 规范](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0)，下面来大致介绍下：\n\n使用 `git commit` 可以提交多行 `commit message`.\n\n`commit message` 包括三个部分：`Header`，`Body` 和 `Footer`\n```\n<type>(<scope>): <subject>\n// 空一行\n<body>\n// 空一行\n<footer>\n```\n其中，`Header` 是必填，`Body` 和 `Footer` 是选填。\n\n\n### `Header`\n`Header` 包括三个字段：`type`（必填）、`scope`（选填）和 `subject`（必填）\n\n#### `type`\n`type` 用于说明 `commit` 的类别，只允许使用下面 7 个标识。\n- feat：新功能（feature）\n- fix：修补bug\n- docs：文档（documentation）\n- style： 格式（不影响代码运行的变动）\n- refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n- test：增加测试\n- chore：构建过程或辅助工具的变动\n\n`type` 为 `feat` 和 `fix`，则该 `commit` 将肯定出现在 `Change log` 之中。\n\n#### `scope`\n`scope` 用于说明 `commit` 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n\n#### `subject`\n`subject` 是 `commit` 目的的简短描述，不超过50个字符\n```\n以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes\n第一个字母小写\n结尾不加句号（.）\n```\n\n### `body`\n`Body` 部分是对本次 `commit` 的详细描述，可以分成多行。下面是一个范例。\n\n```\nMore detailed explanatory text, if necessary.  Wrap it to \nabout 72 characters or so. \n\nFurther paragraphs come after blank lines.\n\n- Bullet points are okay, too\n- Use a hanging indent\n```\n\n### `Footer`\n`Footer` 部分只用于两种情况\n- 不兼容变动\n\n如果当前代码与上一个版本不兼容，则 `Footer` 部分以 `BREAKING CHANGE` 开头，后面是对变动的描述、以及变动理由和迁移方法。\n\n- 关闭 `Issue`\n如果当前 `commit` 针对某个 `issue`，那么可以在 `Footer` 部分关闭这个 `issue` \n```\nCloses #123, #245, #992\n```\n\n# `Commitizen` -- 自动生成合格的 `commit message`\n根据上述的描述，你是不是在感慨写个 `commit message` 好麻烦，这里介绍下 `Commitizen` -- 能够根据提示自动生成符合规范的 `commit message`\n\n## 安装\n```bash\n$ npm install -g commitizen\n```\n\n## 在项目中使用\n然后，在项目目录里，运行下面的命令，使其支持 `Angular` 的 `Commit message` 格式。\n\n```bash\n$ commitizen init cz-conventional-changelog --save --save-exact\n```\n\n## commit \n在提交的时候就可以使用 `git cz` 就可以根据提示，生成自动化的 `commit message`\n![Commitizen](https://user-gold-cdn.xitu.io/2018/10/27/166b47239dd94158?w=640&h=400&f=gif&s=2101792)\n\n# `validate-commit-msg` 检查你的 `commit-message` 规范\n`Commitizen` 可以帮助我们规范自己的 `commit-message`，但是在团队合作中，如何规范其他成员的 `commit` 规范呢？\n\n可以使用 `validate-commit-msg` 来检查你的项目的 `commit-message` 是否符合格式\n\n## `validate-commit-msg` 安装\n```\nnpm install --save-dev validate-commit-msg\n```\n\n## `husky` 安装\n按照 [validate-commit-msg 中 README ](https://github.com/conventional-changelog-archived-repos/validate-commit-msg) 中写的，可以用 `validate-commit-msg` 作为一个 githook 来验证提交消息，并且推荐了 `husky`。\n\n> This provides you a binary that you can use as a githook to validate the commit message. I recommend husky. You'll want to make this part of the commit-msg githook, e.g. when using husky, add \"commitmsg\": \"validate-commit-msg\" to your npm scripts in package.json.\n\n执行\n```bash\nnpm install husky --save-dev\n```\n\n并且在 `package.json` 中的 `scripts` 字段中加入 \n```bash\n\"commitmsg\": \"validate-commit-msg\"\n```\n\n----------------------------\n\n然后每次 `git commit` 之后，就会自动检查 `commit message` 是否合格。如果不合格，就会报错\n```bash\nhusky > commit-msg (node v9.2.1)\nINVALID COMMIT MSG: does not match \"<type>(<scope>): <subject>\" !\nchange\nhusky > commit-msg hook failed (add --no-verify to bypass)\n```\n\n# 生成 Change log\n如果你的所有 commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。\n\n生成的文档包括以下三个部分。\n- New features\n- Bug fixes\n- Breaking changes.\n\n每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\n\n## `conventional-changelog` 自动根据 `commit` 生成 `change log`\n\n### `conventional-changelog` 安装\n\n```bash\nnpm install -g conventional-changelog-cli\n```\n\n### `conventional-changelog` 工作流\n- Make changes\n- Commit those changes\n- Make sure Travis turns green\n- Bump version in package.json\n- conventionalChangelog\n- Commit package.json and CHANGELOG.md files\n- Tag\n- Push\n\n`conventionalChangelog` 这一步有两种选择\n\n```\n# 不会覆盖以前的 Change log，只会在 CHANGELOG.md 的头部加上自从上次发布以来的变动\n$ conventional-changelog -p angular -i CHANGELOG.md -s -p \n\n# 生成所有发布的 Change log\n$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0\n```\n**注意：** \n- 这里安装的是 conventional-changelog-cli，安装 conventional-changelog 会报 conventional-changelog: command not found 的错误\n- 查阅了很多文章使用的是 `conventional-changelog -p angular -i CHANGELOG.md -w`，这样只能在命令行中 log 出 CHANGELOG 的内容，不会生成文件，如果要生成文件需要使用 `conventional-changelog -p angular -i CHANGELOG.md -s`。更多的 config 可以使用 `conventional-changelog --help` 查看\n- 还需要注意的是，在生成 changlog 之前，需要先使用 `$ npm version [version]` 更改版本号，然后再生成 changelog，这一步很多的博文都没有写，就会导致增量生成的 CHANGELOG 一直都有之前的 commit 记录。\n\n### 自动判断版本号\n上面步骤有两个需要优化的地方\n- 需要在 conventionalChangelog 之前先要更改版本号\n- 生成 CHANGELOG.md 之后又造成了新的改动，所以还需要再执行一遍提交\n\n所以我们需要自动化的执行这些，`commitizen` 还依据 `conventional message`，创建起一个生态\n- [conventional-changelog-cl](https://github.com/conventional-changelog-archived-repos/conventional-changelog-cli)：通过提交记录生成 CHANGELOG.md\n- [conventional-github-releaser](https://github.com/conventional-changelog/releaser-tools)：通过提交记录生成 github release 中的变更描述\n- [conventional-recommended-bump](https://github.com/conventional-changelog-archived-repos/conventional-recommended-bump)：根据提交记录判断需要升级 Semantic Versioning 哪一位版本号\n\n使用这些工具可以简化发布流程。\n```bash\ncp package.json _package.json &&\npreset=`conventional-commits-detector` && \necho $preset &&\nbump=`conventional-recommended-bump -p angular` &&\necho ${1:-$bump} &&\nnpm --no-git-tag-version version ${1:-$bump} &>/dev/null &&\nconventional-changelog -i CHANGELOG.md -s -p ${2:-$preset} &&\ngit add CHANGELOG.md package.json package-lock.json &&\nversion=`cat package.json` &&\ngit commit -m'docs(CHANGELOG): $version' &&\nmv -f _package.json package.json &&\nnpm version ${1:-$bump} -m 'chore(release): %s' &&\ngit push --follow-tags \n```\n\n# 在你的项目中规范 `commit message` 并且根据 `commit` 自动生成 `CHANGELOG.md`\n1. 安装依赖\n```bash\nnpm install -g commitizen conventional-changelog conventional-changelog-cli conventional-commits-detector conventional-recommended-bump husky validate-commit-msg\n\n```\n\n安装完成之后版本如下（我遇到过 `conventional-recommended-bump` 是 `4.x` 的版本会报错`Error: Unable to load the \"angular\" preset package. Please make sure it's installed.`。降低下版本就好。\n```\n/usr/local/lib\n├── commitizen@3.0.4\n├── conventional-changelog@2.0.3\n├── conventional-changelog-cli@2.0.5\n├── conventional-commits-detector@0.1.1\n├── conventional-recommended-bump@0.3.0\n└── npm@6.1.0\n```\n2. 在 `package.json` 中增加 `script` 字段\n```bash\n    \"changelog\": \"cp package.json _package.json &&preset=`conventional-commits-detector` && echo $preset && bump=`conventional-recommended-bump -p angular` && echo ${1:-$bump} && npm --no-git-tag-version version ${1:-$bump} &>/dev/null && conventional-changelog -i CHANGELOG.md -s -p ${2:-$preset} && git add CHANGELOG.md package.json package-lock.json && version=`cat package.json` && git commit -m'docs(CHANGELOG): $version' && mv -f _package.json package.json && npm version ${1:-$bump} -m 'chore(release): %s' && git push --follow-tags \"\n```\n\n3. 使用\n使用 `git cz` 就可以根据提示，生成自动化的 `commit message`\n使用 `npm run changelog` 生成 changelog, tag, 升级 version, 并自动执行 git push\n\n# 问题\n改方案还有一个问题尚未解决，就是使用 `conventional-recommended-bump` 更换推荐版本，我实验的项目都是只改动了中间的版本号，如果你的项目对版本号要去比较严格，建议使用手动更换版本号的方式。\n",
            "desc": "![](https://user-gold-cdn.xitu.io/2018/10/27/166b5143d310c620?imageView2/1/w/1304/h/734/q/85/format/webp/interlace/1)  一个好的项目通常都是多人合作的结果，然而每个人有每个人的开发习惯，并不统一。  所以 commit message 就显得格外的重要。有些不规范的 commit 可能过个一个月之后你自己都不知道当时的提交目的了ﾍ(;´Д｀ﾍ)，  所以，为了能使得日后复（zhao）盘（guo）的时候更加的方便，团队之间遵守同一套 commit message 规范还是很有必要的。  本篇文章介绍的是 [Angular 规范](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0)，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。",
            "title": "规范你的 commit message 并且根据 commit 自动生成 CHANGELOG.md",
            "tag": "FE",
            "author": "cherry",
            "__v": 0
        },
        {
            "toc": [],
            "state": "publish",
            "readingQuantity": 0,
            "createAt": "2019-04-15T15:36:29.176Z",
            "updateAt": "2019-04-15T15:38:49.705Z",
            "_id": "5cb4a4fd15b14b29fb28e027",
            "id": null,
            "content": "# 0 玉伯 —— 体验科技与好的社会（蚂蚁金服）\n文字版 https://www.yuque.com/yubo/words/tcaywl\n插播一条前一日蚂蚁金服 SEE_CONF 玉伯的开场\n\n\n![体验科技与好的社会](https://user-gold-cdn.xitu.io/2019/1/8/1682e0e1b8b68c49?w=2023&h=1099&f=png&s=203447)\n\n# 1 圆心 D2 开场 \n\n![圆心开场脑图](https://user-gold-cdn.xitu.io/2019/1/8/1682ce50b2786a05?w=2311&h=2245&f=png&s=578174)\n\n## 五个变化\n\n### 1. PC -> 无线 给前端带来更多的可能性和创造性\n\n- 无线端市场份额越来越多（淘宝 95% 交易在无线端）\n- 无线时代的渲染技术的改变\n- 无线时代性能优化的改变（Yahoo 的 N 条军规不能完全适用）\n- 无线时代基础能力的改变 可以获取更多端提供的方法\n\n\t- LBS\n\t- 摄像头\n\t- 陀螺仪\n\n### 2. nodejs 让前端走到后端 让前端获得更多的能力\n\n- 前端模块化和体系化\n- 前端思维模式的改变（eg:微服务模式）\n- 阿里现在已经有 4000 多个 node 应用\n\n### 3. ToB 体系的到来给中后台有更多的机会\n\n- ToB 体系逐步完善\n- ToB 体系天然的标准化和收敛性催生优秀的 UI 组件库\n\n### 4. 前端工程化的到来\n\n- 前端开发逐步从开发工具到开发工程\n- 前端开发体系逐渐完善\n- 前端走向成熟的标志\n\n### 5. 框架语言的相对成熟\n\n- vue react 两大体系使得前端开发逐步确定\n\n## 三个机会\n\n### 1.  中国特有的小程序提供新的机会\n\n- 除了微信，支付宝、钉钉 等都开始推出自己的小程序\n- 特点：跨平台、高度的安全性、赋能\n\n### 2. AI 智能化带来的新的机会\n\n- AI 智能化的发展并不是和前端完全没有关系（但是区块链和前端真的没有关系 ）\n- 去 code 化（design to code ）\n\n\t- 提高开发效率\n\t- 仍需探索\n\n- 端智能框架\n\n\t- 服务端的算法可以下发到客户端来做\n\t- eg: 淘宝详情页无障碍框架（详情页为图片拼接，如何通过 AI 智能转换为文字供障碍人士阅读）\n\n### 3. PC 桌面带来的机会（Electron）\n\n- 开发模式的改变\n- 云+ 端使得前后端开发更加高效\n\n### 总结\n\n- 唯一不变的就是变化\n- 前端的发展前景还是充满活力并且面临机遇与挑战\n\n\t- 新零售\n\t- 异形屏\n\t- 新一代的交互设备给前端整个体系的挑战\n\n- 相信你所相信的，坚持你所坚持的\n\n# 2 个人收获\n其实我觉得参与本次 D2 给我带来最大的帮助就是让我对我现在所从事的行业更加有信心，因为我们能做的还有很多。\n\n其实之前一直有言论说前端工程师慢慢将会被取代，因为这几年确实有很多优秀的工具出现。\n\n如果你也有这样的担心，那么完全是因为你现在所做的事情就和搬砖的工人是一样的，机械的重复劳动，所以将会被取代的是 **你** 本身，而不是某一个行业，我相信，如果只是机械的劳动的话，不久的将来，都是会被机器替代掉的。\n\n从圆心的发言来看，现如今的社会的发展，计算机的发展和前端的发展，和五年之前或者三年之前都是有很大的变化的。那么面对这些变化，就会有更多的机会和挑战，比如：\n- PC 到无线时代的转变我们可以获得更多端的基础能力\n- Nodejs 让前端开发工程师可以走向后端，无论是业务还是思维方式\n- ToB 体系的完善可以让我们开发出更多的标准化 UI 组件库\n- 中国特有的小程序也会有更多的机遇与挑战\n- PC 桌面我们也可以做更多的事情了\n- AI 智能化逐步会让前端去 code 化（design 2 code）也会催生出更多的端智能框架\n- 特大屏幕和超小屏幕也会给前端开发有更多的开发和挑战\n- 新一代的交互设备给前端整个体系的挑战\n\n也就是说，在未来的几年中，我们所从事的行业还是有很多的领域需要我们去探索的，我们能做的还有更多，同时，未来也还会有无限种可能，未来就掌握在我们每个人的手中，我们每个人都是推动时代进步的一份子。\n\n# 3 个人感悟\n相对于之前参与的 JSConf，本次 D2 收获还是蛮多的，也是从一个刚入行的小菜鸟变成了稍微好一点的小菜鸟(ಥ_ಥ)\n\n你从 D2 这样的分享会能得到什么\n- 想要干货？八成都不是，你能得到的是整体大环境的发展趋势\n- 你可以了解到其他大牛们都在研究什么，开阔技术视野，时不时感慨还可以这样？！ヽ(；´Д｀)ﾉ\n- 获得第一手的学习资料，作者本人直接向你讲述，如果你有问题，作者本人可以给你答疑解惑~~\n- 感受下和大牛们之前的差距，嗯，可能也就是月球到地球的距离吧 (〒︿〒)\n- 学习一下演讲技巧，如何在短时间内让大家理解你想要表达的内容\n- 大型网友见面会，感受下旁边有在微信上问你：“你是不是也来 D2 了呀，我旁边有个人和你很像唉~~”\n- 顺便带走个 <del>女朋友</del> <del>男朋友</del> 基友（也不是没有可能啊喂，上次 饿了么 秋季交流会就有现场带走女朋友的~~~）\n\nD2 分享资料：\n- GraphQL rewrite and performance improvement 》王啟安 / Facebook 前端工程师\n\n  由台湾小哥讲解的 GraphQL，主要讲了 GraphQL 的一些概念使用以及优势 思路清晰通俗易懂，业务痛点和应用场景也有介绍。\n\n  相关资料：https://graphql.org/   http://graphql.cn/\n  \n  一种用于 API 的查询语言：GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。\n\n\n\n- 《你不知道的 Node.js 性能优化》 Starkwang/ 腾讯云前端工程师  https://zhuanlan.zhihu.com/p/50055740\n\n  小哥哥讲的很好，准备非常充分，对内容非常熟悉。讲了一些很实用的优化方法和思路，最后还讲了怎么做性能监控，可以说是很用心的了\n\n- 《如何通过逆向工程 V8 从故障的进程中复活 JavaScript 》张秋怡 / Node.js Technical Steering Committee 的成员\n\n    通过 Node.js 还原事故现场，在 Node.js 事故之前保留所有调试相关的信息，便于事后调试\n    \n    相关资料：llnode ：https://github.com/nodejs/llnode \n\n- 《WebAssembly becoming the biggest platform》Sven Sauleau / TC39成员、Babel 核心成员、 Webpack核心成员、 WebAssembly专家 http://d2-2019.sauleau.com/\n\n    相关资料： http://webassembly.org.cn/ \n\n    WebAssembly/wasm WebAssembly 或者 wasm 是一个可移植、体积小、加载快并且兼容 Web 的全新格式\n- 《Migration To React Suspense》闫畅 / Facebook 前端工程师（https://github.com/cyan33/Migration-to-Suspense）\n\n    主要阐述了 React Suspense 所要解决的问题以及相关的使用\n\n- 《Will \"class fields\" be the new \"bad part\" of JavaScript? 》贺师俊（Hax）/ 百姓网架构部工程师  \n\n- 《从 spritejs 谈完整的 UI 系统设计》winter / 计算机之子 \n\n    主要讲了UI系统的设计/分层，包括围绕spritejs讲了其设计以及一些优化，清晰易懂。\n\n    UI 系统分哪几层，浏览器、Weex、Flutter 分别是如何实现这几层的？\n\n    接着介绍了 SpriteJS 匹配之前所述的 UI 系统各层都采用了哪些实现方案。最后 winter 给了一些关于由 SpriteJS 在 UI 系统图形层、渲染层的展望引出的总结\n- 《Web 渲染引擎中兴之路之技术大揭秘》成国凯 / 阿里巴巴 无线开发专家\n\n    从 U3 到 U4 内核，渲染引擎以及容器都有哪些变化，Rasterization 即光栅化是如何利用 GPU 能力的，从单线程到多线程、多进程和沙箱多进程，Web 平台的演进史，该如何合理使用 Layer？U4 众多新特性介绍，以及滑动性能优化、首屏性能优化、混合渲染等等\n- 《What makes Flutter fast》李宇骞 / Google Flutter 开发 2018谷歌开发者大会讲\n    Less Work（干活少） Better incentiv（激励好）\n- 《淘宝 MiniApp 容器架构探索之路》炼玉 / 阿里巴巴 高级无线开发工程师炼玉 / 阿里巴巴 高级无线开发工程师炼玉 / 阿里巴巴 高级无线开发工程师\n    主要讲手淘在在页面层与底层抽出来一层业务容器层，围绕讲了一些隔离 / 监控 / debug / 性能优化等，主要还是从架构&策略等方面去聊手淘小程序的技术，也聊了一些经典问题比如长列表滚动性能问题如何解决之类\n\n**分享资料很多都是从 https://www.zhihu.com/question/308177332 下 copy 过来的，侵删**\n",
            "desc": "![](https://user-gold-cdn.xitu.io/2019/1/9/1682e353bd1811a2?imageView2/1/w/1080/h/320/q/85/format/webp/interlace/1)机缘巧合，能够参加 13届 D2 前端开发者大会，自己的拖延症又犯了，没有及时将文章整理出来。下次要趁早，不然点赞的人都少了 （o´ﾟ□ﾟ`o）",
            "title": "拥抱变化，无限可能（D2 开场总结）",
            "author": "cherry",
            "__v": 0,
            "tag": "FE"
        },
        {
            "toc": [],
            "state": "draft",
            "readingQuantity": 0,
            "createAt": "2019-04-12T05:22:07.366Z",
            "updateAt": "2019-04-12T05:26:52.102Z",
            "_id": "5cb0207f4bf15234265f32d0",
            "id": null,
            "content": "## 简历的格式\n简历最好在 1-2 页，最好不超过 2 页。简历真的不是字写的多就好，不管是技术还是 hr 都很难一个字一个字看你的简历。所以简历上写的一定是精华，需要写你的优势。\n\n个人不太喜欢花里胡哨的简历，排版整齐就好，但是也要注意不要有错别字，虽然都知道是无心的，但是给人的印象确实不怎么好，最起码可以说明你没有仔细看过你自己的简历，同时最好区分大小写，数字/英文和汉字之前要有空格，这个真的是一个好习惯，之前在掘金翻译的时候养成的习惯，现在就算是微信聊天基本上也都会遵循，极大的提高了阅读效率。\n\n最好不要使用在招聘网站上使用模板生成的简历，同时要记得使用 PPT 模板的时候要把不必要的东西删除啊= =，（收到过简历上第一行是 chapter，也没有姓名，就问他为什么没有名字，然后给我回答 chapter 是英文名= = ）\n\n对于已经毕业 2 年以上的，学生时期的经历（学生会主席、拿过什么什么奖学金）就可以不用写了。\n\n## 简历的内容\n前端这块的简历基本上就基本介绍、技术栈、工作经验、项目经验就可以。\n\n基本介绍写明 姓名、电话和邮箱、毕业时间、学历、出生年月就可以（照片有没有都行、政治面貌、籍贯无所谓），电话一定要真实可以打通的电话（真的遇到过到的简历电话和邮箱中间四位是 **** (ಥ_ಥ)），也遇到过打电话打几次打不通的（工作日和非工作日都联系过），即使您再优秀，联系不上也白搭啊(/□＼*)\n\n\n### 项目经验和投递的 title 相匹配\n个人觉得 9102 年了，会用 JQ 基本就可以不用写在简历上了，如果你研究过（不等于看过）JQ 源码可以酌情写上。\n\n同时，你的简历要和你投递的岗位相匹配，比如 title 是资深前端工程师，那么你能够使用 div + css 写页面就可以不用写在简历上了，因为这应该是最最基本的要求。\n\n简历上是要突出你的优势，同时也是自我总结能力的一个体现\n\n### 简历上写的内容要是你擅长的\n面试的题目很大部分都是从你简历里面问的。所以，对于那种自己只是找了篇文章然后实现了下的项目或者只是写过 demo 的，就不要写在简历里面了。\n\n简历里面写的一定是你全部了解的，因为前端的技术栈或者各种各样的框架层出不穷，面试者基本不会问一个你没听说过的框架，那怎么知道你会什么呢，就从你的简历里面看喽～\n\n我就遇到过很多简历写的很好，但是一问就不知道了。比如有个简历上写的“对面向对象编程有深刻的理解”，我问：“面向对象的三大要素是什么”，回答：“这个概念性的记不清了。”，好吧，那我换一个：“你平时怎么实现封装和继承”回答：“平时项目中基本用不到” ，“那面向对象和面向过程编程有什么区别呢？” 回答的思路不清晰，磕磕巴巴。对于这种情况，个人觉得你最好就不要把“对面向对象编程有深刻的理解”写在简历上了，因为如果你不写，我可能还不会问，但是你掌握的水平和“有深刻理解”差距还是蛮大的，这就是一个减分项了。\n\n还有一个是简历中在个人技能和项目的第一个都写的是“用 node 开发个人博客”，刚好我本人最近也在做这块内容，想着问下。然后回答“其实我是在网上找了篇博客跟着实现了下，现在忘记了”\n\n所以说简历上真的要写你非常了解的领域啊！只是听过名次和写写 demo 的话写在简历上反而是减分项。\n\n### 注意用词\n简历中对某项技术的描述一般有以下几个词语：\n> 了解：理解基本概念，有过简单的使用经验 —— “用过”\n> 熟悉：基本操作很熟练，有过密集的使用经验 ——“用得不少”\n> 精通：深入理解其底层原理及各种实现方式，并有丰富的项目经验——“有研究”\n\n切记准确用词，慎用“精通”！！\n\n# 电面\n收到简历之后我们一般都会先进行一轮电话面试（每个公司的流程不一样），因为成本比较低嘛，问一些基础问题大概就可以知道面试者的水平在哪个范围了，和我们招聘的岗位的匹配程度如何。\n\n同时，我建议面试者被邀现场面试之前最好也进行下电话沟通，如果直接现场面的话最少你要请半天假吧，如果说双方的匹配程度比较低就不用白跑一趟了。\n\n我们这边电面以基础为主，如果基本能够符合我们的招聘要求，再约现场面。\n\n我个人认为，基础比较好（不仅仅是 js 基础，还有计算机体系基础和编程基础），三大框架熟悉其一并略懂原理 这两点是最起码的，自己用 webpack 配置过项目懂得 webpack 打包原理、学习过框架源码、对性能优化有过实践、对新技术的了解程度 这些都是加分项（因为我们项目中没有用到 node，node 基本不会问，除非你在简历中写有）。\n\n并且也会考虑面试者的综合素质，主要是表达能力（沟通无碍就好）、性格是否十分内向、回答问题是否条理清晰。\n\n我个人的话会有一个常问的面试题库，然后在电面前根据面试者的简历筛选要问的问题，比如前面说到的，你简历中写有“对面向对象有深刻的理解”，那么我就会准备几个面试对象的问题。\n\n整体来说，电面之后就基本可以确定了面试者和我们招聘岗位的匹配程度，在面试的过程中会记录下面试者的回答情况，对于有明确答案的问题看其是否回答正确，对于开放性问题，看其思路是否清晰。\n\n我个人的话问框架 api 都是一些比较常用基础的 api，考察下你使用到什么程度，比较会问一些原理，比如 vue 的双向绑定原理（vue 2.0 和 vue 3.0，两种实现的优缺点）、vue 的 nexttick 原理、diff 算法等。\n\n我们在电面完之后通常都会问面试者有什么问题想要问我们的，大部分面试者会问我们组所做的业务，也会被问到技术方面的问题= = =，一般这个环节都是看下面试者有什么诉求的，就是你如果有什么强烈的诉求可以问下。\n\n电面完之后一般不会直接说是否通过，都会说“后续**可能**还会有其他同事联系您”，但是根据点面的过程，应该自己心里都会有个大概吧= =\n\n关于为什么不直接给答案，一方面是处于礼貌:)，一方面是可能当时并不能及时给出结果。\n\n同时，如果是当场给你说面试没有通过，那么如果面试几天下来，其他人并没有你优秀= =，再接着联系你也不太好。\n\n所以一个比较好的方法就是面试完需要考虑下才能给出答复，并且一般就算面试没有过也不会再给你说没有过。所以默认一周之内如果没有 hr 再联系你，基本就可以认为是面试没有过了。\n\n# 现场面\n一般电面之后我们会找 hr 小姐姐约现场面试，对于现场面试我并没有太多的经验，这里只是给出参考意见。\n\n现场面就看各个面试官的习惯了，有的会继续问一些技术，有的会重视项目经验，我们这是现场技术面之后要给一个定级，看是否达到招聘要求。\n\n一般情况下是第一轮面试之后如果能给定级那么就找我们技术 leader 来聊下，把把关，没啥问题再找 hr 小姐姐来聊下，\n\n# 给刚毕业大学生的一点建议\n## 刚毕业找工作并不是全看技术\n在刚毕业的时候我会认为找工作是只看技术的，毕竟我们是技术岗位。\n\n但是现在自身的感觉包括也和其他小伙伴聊过之后发现技术有的时候占比也没有想象那么高。\n\n因为其实我们毕业之后 1 -2 年内并不是特别能拉开差距，大家的水平相差都不是特别大。\n\n这个时候可能一些其他的品质更重要，比如你的沟通能力、你的性格、是否踏实。\n\n同时，找工作这个事情，运气和缘分也是很重要的，比如当时的岗位是否是急缺岗位，如果是新增的部门或者刚好有人离职需要补位，这些特殊情况下，可能要求会稍微降低些（绝对不会降低太多）。\n\n所以最好是找团队人员内推，这样对团队的情况会更加了解。\n\n但是个人觉得，3 年之后技术水平的差距就会越来越大了，并且想要缩短差距也会越来越难。\n\n## 刚毕业尽量去大公司\n其实就和你上大学选择名校还是一般学校，有些人说不想当大公司的螺丝钉的时候可以先问下自己能不能够进入大公司，不要还没有进入就开始酸。\n\n有能力去而选择不去和去不了是两个概念。\n\n从自身以及周围人的经验而谈，大公司你能学到的东西从各方面都是比小公司强一点的（这里说的小公司不代表某些小而精的公司）。\n\n个人经验而言，大公司并不是每个人都是螺丝钉，做重复的劳动，因为你所对接的部门有很多，你需要和各种各样的前端、后端、产品、设计、QA 接触，每个人的习惯都不尽相同，也会遇到跨部门合作，不同部门的技术栈可能会不一样，所以，你所接触的东西是多元化的；\n\n相反，小公司所接触的前端、后端、设计和 QA 基本都比较固定，基本上也不会有跨部门合作的需求，并且技术栈相对而言比较固定，使用了一套技术栈基本也不会换，所以你的技术提升视野可能会稍微窄一点。\n\n并且大公司的业务复杂程度和用户数量也是小公司所不能提供的。\n\n说句实在话，简历中有知名互联网公司的工作经验是很加分的，基本都能有个面试资格，因为从某种程度降低了成本，因为既然能够去知名互联网公司，说明肯定是有优势的。\n\n## 不要只会 API，要了解其原理\n我们老大经常给我们说过的一句话是：“不要只会一些 API 的东西”，现在前端的一个现象是，很多人使用了一些 API，就觉得掌握了某些知识。\n\n要注重一些底层知识，一些原理，这才是长远发展的必备技能。\n\n比如在电面的时候问：“一句话概述下什么是 promise”，很多人都回答 promise 的使用方法。\n\n## 找工作是双向选择的过程，一个好的团队很重要\n找工作真的是双向选择的过程，不仅仅是公司选择你，也是你选择公司的过程，有能力的话最好找一个好的团队，做的业务是自己喜欢的，最起码不能太反感不是。\n\n其实从面试官你基本也可以判断出该团队的水平，个人的一点看法是，如果你本身还处于成长阶段，如果面试时候问的问题你都可以顺利的回答出，那么该工作你就要慎重考虑下，可能成长空间会小一点。 \n\n## 减少跳槽的频率\n关于跳槽频率，这个不管是技术 leader 和 hr 都是考虑的一个问题。\n\n因为前几年，个人感觉涨薪的最便捷途径就是跳槽，涨薪幅度会比较高，在一家公司等加薪比较慢。\n\n但是如果你跳槽过于频繁其实是不利的，个人认为，一年跳槽一次这个频率就有些高了。\n\n京东也是将这点明确有要求的，一票否决制度，五二原则（五年内之内最多在两家公司）\n\n## 关于学历\n现在很多公司的门槛都是本科相关专业毕业，并且以后的要求肯定会越来越高。\n\n每个公司要求不一样。\n## 觉得面试中有些问题工作中用不到\n很多人都会有这样的一个问题：觉得面试中问的很多问题在实际工作中根本用不到。\n\n我觉得你会有这样的问题可能是你和这个公司的岗位并不相匹配。\n\n因为当时我面试饿了么的时候，问我了一些简单的算法的问题和一些底层原理，但是面试的时候还有些吐槽。\n\n入职之后，发现面试问的问题在工作中确实用到了，并且在自己准备面试题的过程中，也是根据平时的工作经验总结的。\n\n自己当时觉得用不到是因为之前的业务场景不够复杂，用户量不够大，所以有些知识点用不到，很多产品需求都是需要自己实现的，现有的组件不能满足，有些问题。\n\n比如自己需要实现一个组织架构树，对每一个节点进行不同的操作，有的时候还需要 table 和 tree 相结合，一些比较复杂的节点数据可能比较多，所以还需要考虑性能优化的问题。\n\n所以面试的时候就会问: 如何遍历一个树，并对其进行优化。\n\n## 注重底层原理和概念的学习\n有的人会问 底层知识，原理有没有用？？\n答案肯定是有用的！！\n\n对于一个人的技能，我觉得最重要的是解决问题的能力，因为我们的工作其实就是解决一个又一个的问题，不管是从产品层面还是从技术层面，都是将这个问题解决。\n\n而你了解更多的底层知识，更多的原理知识，都是提高你解决问题的能力，如果你知道 api 背后的原理就能更好的选择使用哪个 api。\n\n并且了解底层知识和原理也会提高你排查问题的能力，因为你工作中总会遇到：“明明就是这样的啊，为什么报错啊，为什么不能用啊，为什么和预期不对啊”，你如果只是知道 api 是怎么使用的，有的时候是没办法很好的排查问题的。\n\n下面是我个人的面试题\n\n# 部分面试题（答案仅供参考，不保证其正确性）\n## CSS\n### Q1：怎么实现三列布局（左侧和右侧宽度固定，中间自适应）\n[常见 CSS 布局](https://cherryblog.site/common-CSS-layout.html)\n\n> 该问题主要想了解面试者的思维是否有局限性，实现该布局是一个比较常见并且方法很多的一种布局方式，并且可以引导面试者一步一步回答 CSS 相关的基础问题。\n\n- 绝对定位 + 中间版块不给宽度\n- 两侧浮动 + 中间自动撑开（使用 calc 动态计算宽度，设置对应宽度的 margin）\n- flex，左右设置 flex-basis，中间设置 flex-grow\n\n> 基本上最常见的答案是这三种布局方式，但是很多人都只说一个 flex，其他两种布局方式稍微考虑下就可以想到（o´ﾟ□ﾟ`o），该问题不是想让面试者回答出什么奇淫技巧，只是对 CSS 基础知识的一个考察。\n\n#### Q 1-1: flex 具体是怎么实现三列布局的（左侧和右侧的宽度是怎么设置的，中间自适应使用的是哪个属性）\n\n> flex 设置宽度和宽度自适应应该算是 flex 的最基本用法，在面试中，问到 flex 的设置宽度和中间自适应具体是哪个属性，很多面试者都回答“不记得了，平时都是自动填充的”\n\n#### Q 1-2: 设为 flex 属性之后，子元素的哪些属性会失效\nfloat、clear 和 vertical-align\n#### Q 1-3  float/绝对定位 怎么实现中间宽度自适应\n\n### Q2: 移动端开发 rem 布局的原理（rem 单位换算）\n### Q3: 有没有自己写过组件\n#### Q 3-1: 怎么实现样式的继承和复用\n#### Q 3-2: 你平时都是怎么管理自己的 CSS\n- base.css、common.css、page.css（对应都存放哪些内容）\n\n#### Q 3-3: 你平时都是使用 sass/lass/styles 的哪些功能，sass 的计算属性对页面性能有影响吗？\n\n### Q4: 如何在页面上画一个圆\n- SVG\n- CANVAS\n- css border-radius\n- background \n- map + area \n- 直接放一张圆形图片\n\n#### Q 4-1: 如何在页面上画一个椭圆\n```\n<style>\n  .sector {\n    width: 0;\n    height: 0;\n    border-width: 50px;\n    border-style: solid;\n    border-color: #f00 transparent transparent;\n    border-radius: 50px;\n  }\n</style>\n```\n\n#### Q 4-2: 如果圆边界模糊，有什么办法去锯齿\n\n> 这几个问题基本上可以了解到面试者平时都是怎么使用 CSS 的了，对于 CSS，我觉得够用就好，因为我们现在基本急太处理兼容性问题（有 babel 并且我们的项目不要求兼容 ie6 等古老的浏览器）\n\n## JS\n### Q1: JS 基本数据类型\nhttps://cherryblog.site/deepcopy.html\n\n#### Q 1-1 JS 数据类型有哪些，其中基本数据类型有哪些\n- Boolean\n- Null\n- Undefined\n- Number\n- String\n- Symbol (ECMAScript 6 新定义)\n- Object\n- (ES6之前)其中5种为基本类型:string,number,boolean,null,undefined,ES6出来的Symbol也是原始数据类型 ，表示独一无二的值。Object 为引用类型(范围挺大),也包括数组、函数\n\n#### Q: 1-2 原始数据类型和引用类型的区别\n在内存中的存储方式不同，原始数据类型在内存中是堆存储，引用类型是栈存储\n栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。\n\n在内存中存储方式的不同导致了原始数据类型不可变\n原始数据类型和引用数据类型做赋值操作一个是传值一个是传址\n#### Q: 1-3  深拷贝 和 浅拷贝 的区别\nhttps://cherryblog.site/deepcopy.html\n\n#### Q: 1-4 怎么实现浅拷贝\n- ES6：object.assign()\n- 展开运算符…\n- 自己封装函数实现\n\n#### Q: 1-5 怎么实现一个深拷贝\n- JSON.parse() (但是如果里面有 function 和 undefined  不可用)\n- lodash\n- 自己封装\n\n#### Q: 1-6 null和undefined的差异\n相同点: \n- 在 if判断语句中,值都默认为 false\n- 大体上两者都是代表无,具体看差异\n差异:\n- null转为数字类型值为0,而undefined转为数字类型为 NaN(Not a Number)\n- undefined是代表调用一个值而该值却没有赋值,这时候默认则为undefined\n- null是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)\n- 设置为null的变量或者对象会被内存收集器回收\n\n> 这个问题是一个 JS 基础相关的问题，可以考察面试者 JS 基本功\n\n### Q2: 实现给数字添加千分位符的方法\n- 正则表达式：\"12345678\".replace(/(\\d)(?=(?:d{3})+$)/g, '$1,')\n- 字符串分析， 循环，然后3位加','\n- 数字分析， 取到整数部分， %1000 操作， 然后加逗号 拼接字符串\n(12345678).toLocaleString(\"en-US\") => \"12,345,678\"\n\n### Q3: 面向对象三大要素（https://cherryblog.site/javascript-oop.html）\n- 封装、继承、多态\n\n#### Q3-1: 能够简单的说明面向对象和面向过程的区别吗\n- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。\n- 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。\n- 面向对象： 狗.吃(屎)\n- 面向过程： 吃.(狗,屎)\n\n#### Q3-4: 怎么实现封装和继承\n#### Q3-5: 一句话概述什么是闭包\n### Q4: 一句话概述什么是 promise\n\n> The Promise object is used for asynchronous computations. A Promise represents a single asynchronous operation that hasn't completed yet, but is expected in the future.\n\n> 译文：Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。\n\n### Q 4-1: promise 解决了哪些问题\n### Q 4-2: 在没有 promise 之前，怎么解决异步回调\n[JS 异步回调的 4 种解决方案](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)\n\n### Q 4-3: 自己如何实现一个 promise（https://blog.csdn.net/chaunceyw/article/details/78007842）\n- new Promise(fn) 返回一个promise对象\n- 在fn 中指定异步等处理\n  - 处理结果正常的话，调用resolve(处理结果值)\n  - 处理结果错误的话，调用reject(Error对象)\n\n> promise 也是一道常见的面试题，在开始问什么是 promise 的时候，很少有人能够用一个话说出什么是 promise，都只是说 promise 的 api 怎么使用，包括闭包，也很少有人能够用一句话概括什么是闭包。个人感觉不能用一句话概括都是理解的不够深入或者没有从更高的层面理解\n\n### Q5: eventloop\n在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去，当执行栈为空的时候，主线程会首先查看微任务中的事件，如果微任务不是空的那么执行微任务中的事件，如果没有在宏任务中取出最前面的一个事件。把对应的回调加入当前执行栈...如此反复，进入循环。\n\n- macro-task(宏任务)\n  - setTimeout\n  - setInterval\n  - setImmediate\n- micro-task(微任务)\n  - Promise\n  - process.nextTick\n\n> eventloop 也是一个很常见的面试题，也是回答出来比较高的一个问题，可以写一个函数，让面试者回答输出\n\n## 计算机相关\n### Q1 :比较 HTML XML XHTML 和 JSON\n- 我们最熟悉的就是 HTML（HyperText Markup Language / 超文本标记语言），用来描述和定义\n网络内容的标记语言，超文本的意思是说，除了能标记本文，还能标记 图片，视频，链接 等其他内容\n\n- XML（Extensible Markup Language / 可扩展标记语言），表现就是给一堆文档加上标签，说明里面的数据是什么意思，方便存储、传输、分享数据。和 HTML 的区别是 HTML 的标签就预定义的，XML 是可扩展的\nXHTML: Extensible Hypertext Markup Language / 可扩展超文本标记语，其实就是 HTML 的严格语法形式，约定了 属性名必需小写，空元素必需关闭，元素名小写，属性名必需加引号，布尔类型必需加属性值\n- JSON（Javascript Object Notation）比较轻量级的数据交换格式，由键值对组成，数据格式比较简单, 易于读写, 格式都是压缩的, 占用带宽小\n\n> 这个问题确实是一个很基础的计算机先关的问题，但是很多的面试者仍然不能准确的说出 HTML 的含义（超文本标记语言），在说 XML 和 JSON 的区别的时候只能回答出 XML 常用作配置文件，JSON 用于 AJAX 传输数据\n\n### Q2: 概述输入一个url到网页呈现的过程\n#### Q 2-1: DNS 解析的详细过程\n#### Q 2-2: 概述 http 的缓存控制（http2 与相关缓存控制）\n#### Q 2-3: 简述三次握手\n#### Q 2-4: 页面加载白屏的原因有哪些，以及如何监控白屏时间，如何优化\n#### Q 2-5：script 标签的属性有哪些\n#### Q 2-6: script 标签的 defer 和 async 标签的作用与区别\n#### Q 2-7: script intergrity的作用\n\n> 这个问题真的是前端面试必问问题，因为能全方面考察面试者的能力，能根据面试者的回答层层层深入，引申出好多问题\n\n### Q3: 你所接触的前端领域的通讯有哪些（https://github.com/rainjay/blog/issues/4）\n- 前端和后端\n- 前端和移动端\n- 前端 父页面 和 iframe 之间\n- 浏览器各个 tab 之间\n- web workers 线程通信\n- 路由间的通信\n- vue 父子组件\n\n### Q 3-1: 通信的要点和目的\n要点：1. 发送者和接收者 2. 传输媒介 3. 传输的数据 4. 传输格式（协议）\n\n目的：1. 同步数据 2. 传递指令(执行的方法)\n\n## 框架\n### Q1: 三大框架解决了传统 JQ 开发的哪些问题\n使前端不用再操纵 DOM,数据驱动，通过数据的改变直接改变 DOM\n#### Q 1-1: Vue2.0 怎么实现双向绑定的\n####  Q 1-2: Vue3.0 怎么实现双向绑定的\n####  Q 1-3: Object.defineProperty() 和 proxy 的区别\n### Q2: 你使用过哪些 Vue/React 全家桶，分别解决了什么问题\n### Q3: Vue/React 的 diff 算法\n### Q4: Vue hash 路由和 history 路由的区别\n### Q5: Vue 计算属性和 watch 在什么场景下使用\n### Q6: Vue 的 nexttick 实现的原理\n\n> 对于 Vue/React/Angular 三大框架会使用哪些 api 是次要的，主要是要了解框架解决的问题和实现原理。\n\n## 打包工具\n### Q1: webpack 相关，是否自己配置过 \n#### Q1-1: webpack 和其他自动化构建工具（gulp、grunt、rollup）有哪些区别（https://juejin.im/post/5b10c6786fb9a01e7c27761b）\n- webpack 是 module bundle\n- gulp 是 tast runner\n- Rollup 是在 Webpack 流行后出现的替代品。Rollup 在用于打包 JavaScript 库时比 Webpack 更加有优势，因为其打包出来的代码更小更快。 但功能不够完善，很多场景都找不到现成的解决方案。\n\n#### Q1-2: 模块化解决了前端的哪些痛点\n- 命名冲突\n- 文件依赖\n- 代码复用\n\n#### Q1-3: webpack 的 loader 和 plugin 区别，举几个常用的 loader 和 plugin 并说出作用\n- loader 用于对模块的源代码进行转换。loader 可以使你在 import 或\"加载\"模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！\n因为 webpack 本身只能处理 JavaScript，如果要处理其他类型的文件，就需要使用 loader 进行转换，loader 本身就是一个函数，接受源文件为参数，返回转换的结果。\n- Plugin 是用来扩展 Webpack 功能的，通过在构建流程里注入钩子实现，它给 Webpack 带来了很大的灵活性。\n通过plugin（插件）webpack可以实 loader 所不能完成的复杂功能，使用 plugin 丰富的自定义 API 以及生命周期事件，可以控制 webpack 打包流程的每个环节，实现对 webpack 的自定义功能扩展。\n\n#### Q1-4: webpack 打包的过程\n- 读取文件，分析模块依赖\n- 对模块进行解析执行（深度遍历）\n- 针对不同的模块使用不同的 loader\n- 编译模块，生成抽象语法树（AST）\n- 遍历 AST，输出 JS\n\n#### Q1-5: webpack 打包之后生成哪些文件\n### Q2: webpack 打包出来的文件体积过大怎么办\n### Q3: webpack 热部署的原理\n### Q4: webpack 打包速度过慢怎么办？\n\n> 关于 webpack ，对于初级前端，基本上只需要可以 cli 将项目起来，知道 loader 和 plugin 的区别以及常用的 loader、plugin 个人觉得就差不多了，但是对于 高级前端及以上，最好还是了解下 webpack 相关的原理\n\n\n## GIT 相关\n### Q1: git rebase\n### Q2: git cherrypick",
            "desc": "![](https://user-gold-cdn.xitu.io/2019/3/15/16981d5520c99538?imageView2/1/w/1304/h/734/q/85/format/webp/interlace/1)最近到了金三银四的跳槽季，很多人都会面临跳槽找工作，并且再过几个月又会到毕业季，越来越多的毕业生会面临这个问题。  同样，我们组因为业务需要（我们今年倒是还没有人员离职，感动╭(╯^╰)╮）需要进行社招，我最近看了不少简历，并且对一些小伙伴进行了电话沟通（电面），对面试找工作有一些自己浅薄的观点  因为个人认为本人的技术还是很菜的，并且工作经验也没有特别丰富，所以文章内容都是自己一些浅薄的看法观点，若有不对之处，欢迎大家指出，不喜勿喷啊, 本篇文章可能只是适用于初级前端，也就是刚毕业的大学生或者毕业 2 年之内的小伙伴，大家酌情阅读~~~",
            "title": "写给初级前端的面试经验",
            "tag": "Interview",
            "author": "cherry",
            "__v": 0
        }
    ],
    "total": 6
}